{
  "language": "Solidity",
  "sources": {
    "contracts/Credit/CreditFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interface/ICreditFeeManager.sol\";\nimport \"./interface/ICreditManager.sol\";\nimport \"./interface/ICreditRoles.sol\";\nimport \"./interface/ICreditRequest.sol\";\nimport \"./interface/ICreditPool.sol\";\n\ncontract CreditFeeManager is ICreditFeeManager, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* ========== CONSTANTS ========== */\n\n    uint32 private constant MAX_PPM = 1000000;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20Upgradeable public collateralToken;\n    ICreditManager public creditManager;\n    ICreditRoles public creditRoles;\n    ICreditRequest public creditRequest;\n    uint256 public underwriterFeePercent;\n    mapping(address => mapping(address => uint256)) accruedFees;\n\n    /* ========== INITIALIZER ========== */\n\n    function initialize(\n        address _creditManager,\n        address _creditRoles,\n        address _creditRequest,\n        uint256 _underwriterPercent\n    ) external virtual initializer {\n        __Ownable_init();\n        creditManager = ICreditManager(_creditManager);\n        collateralToken = IERC20Upgradeable(creditManager.getCollateralToken());\n        creditRoles = ICreditRoles(_creditRoles);\n        creditRequest = ICreditRequest(_creditRequest);\n        require(\n            _underwriterPercent <= MAX_PPM,\n            \"CreditFeeManager: underwriter percent must be less than 100%\"\n        );\n        underwriterFeePercent = _underwriterPercent;\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    function collectFees(\n        address _network,\n        address _networkMember,\n        uint256 _transactionAmount\n    ) external override onlyNetwork {\n        uint256 creditFee = creditManager.calculatePercentInCollateral(\n            _network,\n            underwriterFeePercent,\n            _transactionAmount\n        );\n        collateralToken.safeTransferFrom(_networkMember, address(this), creditFee);\n        creditRequest.verifyCreditLineExpiration(_network, _networkMember, _transactionAmount);\n        accruedFees[_network][_networkMember] += creditFee;\n        emit FeesCollected(_network, _networkMember, creditFee);\n    }\n\n    function distributeFees(address _network, address[] memory _networkMembers) external {\n        for (uint256 i = 0; i < _networkMembers.length; i++) {\n            uint256 fees = accruedFees[_network][_networkMembers[i]];\n            accruedFees[_network][_networkMembers[i]] = 0;\n            address underwriter = creditManager.getCreditLineUnderwriter(\n                _network,\n                _networkMembers[i]\n            );\n            if (underwriter == address(0)) {\n                return;\n            }\n            address pool = creditManager.getCreditLine(_network, _networkMembers[i]).creditPool;\n            uint256 leftoverFee = stakeNeededCollateralInPool(\n                _network,\n                _networkMembers[i],\n                pool,\n                underwriter,\n                fees\n            );\n            if (leftoverFee > 0) {\n                ICreditPool(pool).notifyRewardAmount(address(collateralToken), leftoverFee);\n                emit PoolRewardsUpdated(pool, leftoverFee);\n            }\n        }\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyCreditOperator {\n        IERC20Upgradeable(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n    }\n\n    function updateUnderwriterFeePercent(uint256 _feePercent) external onlyCreditOperator {\n        require(_feePercent <= MAX_PPM, \"CreditFeeManager: invalid fee percent\");\n        underwriterFeePercent = _feePercent;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function calculateFees(address _network, uint256 _transactionAmount)\n        external\n        view\n        override\n        returns (uint256 creditFee)\n    {\n        creditFee = creditManager.calculatePercentInCollateral(\n            _network,\n            underwriterFeePercent,\n            _transactionAmount\n        );\n    }\n\n    function getCollateralToken() external view override returns (address) {\n        return address(collateralToken);\n    }\n\n    function getUnderwriterPoolStakePercent(address _network, address _networkMember)\n        public\n        returns (uint256)\n    {\n        address pool = creditManager.getCreditLine(_network, _networkMember).creditPool;\n        address underwriter = creditManager.getCreditLineUnderwriter(_network, _networkMember);\n        uint256 underwriterCollateral = ICreditPool(pool).balanceOf(underwriter);\n        uint256 totalCollateral = ICreditPool(pool).totalSupply();\n        return (totalCollateral / underwriterCollateral) * MAX_PPM;\n    }\n\n    function getAccruedFees(address[] memory _members, address _network)\n        external\n        view\n        returns (uint256 totalFees)\n    {\n        for (uint256 i = 0; i < _members.length; i++) {\n            totalFees += accruedFees[_network][_members[i]];\n        }\n    }\n\n    /* ========== PRIVATE ========== */\n\n    function stakeNeededCollateralInPool(\n        address _network,\n        address _networkMember,\n        address pool,\n        address underwriter,\n        uint256 creditFee\n    ) private returns (uint256) {\n        if (creditManager.isPoolValidLTV(_network, pool)) return creditFee;\n        uint256 neededCollateral = creditManager.getNeededCollateral(_network, _networkMember);\n        if (neededCollateral == 0) {\n            return creditFee;\n        }\n        if (neededCollateral > creditFee) {\n            collateralToken.safeTransfer(underwriter, creditFee);\n            ICreditPool(pool).stakeFor(underwriter, creditFee);\n            emit UnderwriterRewardsStaked(underwriter, creditFee);\n            creditFee = 0;\n        } else {\n            collateralToken.safeTransfer(underwriter, neededCollateral);\n            ICreditPool(pool).stakeFor(underwriter, neededCollateral);\n            emit UnderwriterRewardsStaked(underwriter, neededCollateral);\n            creditFee -= neededCollateral;\n        }\n        return creditFee;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyCreditOperator() {\n        require(\n            creditRoles.isCreditOperator(msg.sender),\n            \"CreditFeeManager: Caller is not credit operator\"\n        );\n        _;\n    }\n\n    modifier onlyNetwork() {\n        require(creditRoles.isNetwork(msg.sender), \"CreditFeeManager: Caller is not a network\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/Credit/interface/ICreditFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICreditFeeManager {\n    event FeesCollected(address network, address member, uint256 totalFee);\n\n    event PoolRewardsUpdated(address underwriter, uint256 totalRewards);\n\n    event UnderwriterRewardsStaked(address underwriter, uint256 totalStaked);\n\n    function collectFees(\n        address _network,\n        address _networkMember,\n        uint256 _transactionValue\n    ) external;\n\n    function getCollateralToken() external returns (address);\n\n    function calculateFees(address _network, uint256 _transactionAmount)\n        external\n        view\n        returns (uint256 creditFee);\n}\n"
    },
    "contracts/Credit/interface/ICreditManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICreditManager {\n    struct CreditLine {\n        address creditPool;\n        uint256 issueDate;\n        uint256 creditLimit;\n    }\n\n    event CreditLineCreated(\n        address network,\n        address networkMember,\n        address pool,\n        uint256 creditLimit,\n        uint256 timestamp\n    );\n\n    event CreditPoolAdded(address pool, address underwriter);\n\n    event CreditLineLimitUpdated(address network, address networkMember, uint256 creditLimit);\n\n    event CreditLinePoolUpdated(address network, address networkMember, address pool);\n\n    event CreditLineRemoved(address network, address networkMember);\n\n    event CreditLineRenewed(address network, address networkMember, uint256 timestamp);\n\n    function createCreditLine(\n        address _networkMember,\n        address _pool,\n        uint256 _creditLimit,\n        address _network\n    ) external;\n\n    function getCollateralToken() external returns (address);\n\n    function getMinLTV() external returns (uint256);\n\n    function getCreditLine(address _network, address _networkMember)\n        external\n        returns (CreditLine memory);\n\n    function getCreditLineUnderwriter(address _network, address _networkMember)\n        external\n        returns (address);\n\n    function isPoolValidLTV(address _network, address _networkMember) external returns (bool);\n\n    function isCreditLineExpired(address _network, address _networkMember) external returns (bool);\n\n    function swapCreditLinePool(\n        address _network,\n        address _networkMember,\n        address _pool\n    ) external;\n\n    function extendCreditLine(\n        address _network,\n        address _networkMember,\n        uint256 _creditLimit\n    ) external;\n\n    function convertNetworkToCollateral(address _network, uint256 _amount)\n        external\n        returns (uint256);\n\n    function renewCreditLine(address _network, address _networkMember) external;\n\n    function getNeededCollateral(address _network, address _networkMember)\n        external\n        returns (uint256);\n\n    function calculatePercentInCollateral(\n        address _networkToken,\n        uint256 _percent,\n        uint256 _amount\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/Credit/interface/ICreditRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICreditRoles {\n    event UnderwriterAdded(address underwriter);\n\n    event UnderwriterRemoved(address underwriter);\n\n    function grantUnderwriter(address _underwriter) external;\n\n    function revokeUnderwriter(address _underwriter) external;\n\n    function grantNetwork(address _network) external;\n\n    function revokeNetwork(address _network) external;\n\n    function isUnderwriter(address _underwriter) external view returns (bool);\n\n    function isNetwork(address _network) external view returns (bool);\n\n    function isCreditOperator(address _operator) external view returns (bool);\n\n    function isRequestOperator(address _operator) external returns (bool);\n\n    function grantRequestOperator(address _requestOperator) external;\n\n    function revokeRequestOperator(address _requestOperator) external;\n}\n"
    },
    "contracts/Credit/interface/ICreditRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICreditRequest {\n    struct CreditRequest {\n        bool approved;\n        bool unstaking;\n        uint256 creditLimit;\n    }\n\n    event CreditRequestCreated(\n        address network,\n        address networkMember,\n        address requester,\n        uint256 creditLimit,\n        bool approved\n    );\n\n    event CreditRequestUpdated(\n        address network,\n        address networkMember,\n        uint256 creditLimit,\n        bool approved\n    );\n\n    event CreditRequestRemoved(address network, address networkMember);\n\n    event UnstakeRequestCreated(address network, address networkMember);\n\n    function createRequest(\n        address _network,\n        address _networkMember,\n        uint256 _creditLimit\n    ) external;\n\n    function approveRequest(address _network, address _networkMember) external;\n\n    function updateRequestLimit(\n        address _network,\n        address _networkMember,\n        uint256 _creditLimit,\n        bool _approved\n    ) external;\n\n    function deleteRequest(address _network, address _networkMember) external;\n\n    function verifyCreditLineExpiration(\n        address _network,\n        address _networkMember,\n        uint256 _transactionValue\n    ) external;\n}\n"
    },
    "contracts/Credit/interface/ICreditPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICreditPool {\n    function notifyRewardAmount(address _rewardsToken, uint256 reward) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function stakeFor(address _staker, uint256 _amount) external;\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function reduceTotalCredit(uint256 _amountToAdd) external;\n\n    function increaseTotalCredit(uint256 _amountToRemove) external;\n\n    function getUnderwriter() external view returns (address);\n\n    function getTotalCredit() external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Credit/CreditPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interface/ICreditPool.sol\";\nimport \"./interface/ICreditRoles.sol\";\nimport \"./interface/ICreditManager.sol\";\n\ncontract CreditPool is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ICreditPool\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* ========== STATE VARIABLES ========== */\n\n    struct Reward {\n        address rewardsDistributor;\n        uint256 rewardsDuration;\n        uint256 periodFinish;\n        uint256 rewardRate;\n        uint256 lastUpdateTime;\n        uint256 rewardPerTokenStored;\n    }\n\n    IERC20Upgradeable public stakingToken;\n    ICreditRoles private creditRoles;\n    mapping(address => Reward) public rewardData;\n    address[] public rewardTokens;\n    address underwriter;\n    uint256 totalCredit;\n\n    // user -> reward token -> amount\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    /* ========== INITIALIZER ========== */\n\n    function initialize(\n        address _creditManager,\n        address _creditRoles,\n        address _underwriter\n    ) external virtual initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        underwriter = _underwriter;\n        stakingToken = IERC20Upgradeable(ICreditManager(_creditManager).getCollateralToken());\n        creditRoles = ICreditRoles(_creditRoles);\n    }\n\n    function addReward(\n        address _rewardsToken,\n        address _rewardsDistributor,\n        uint256 _rewardsDuration\n    ) public onlyOwnerOrUnderwriter {\n        require(\n            rewardData[_rewardsToken].rewardsDuration == 0,\n            \"CreditPool: reward token already exists\"\n        );\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].rewardsDistributor = _rewardsDistributor;\n        rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n    }\n\n    /* ========== VIEWS ========== */\n    function viewMapping(address _rewardsToken) public view returns (Reward memory) {\n        return rewardData[_rewardsToken];\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return _balances[_account];\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256) {\n        return MathUpgradeable.min(block.timestamp, rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken) public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            rewardData[_rewardsToken].rewardPerTokenStored +\n            (((lastTimeRewardApplicable(_rewardsToken) - rewardData[_rewardsToken].lastUpdateTime) *\n                rewardData[_rewardsToken].rewardRate *\n                1e18) / _totalSupply);\n    }\n\n    function earned(address account, address _rewardsToken) public view returns (uint256) {\n        return (((_balances[account] *\n            (rewardPerToken(_rewardsToken) - userRewardPerTokenPaid[account][_rewardsToken])) /\n            1e18) + rewards[account][_rewardsToken]);\n    }\n\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256) {\n        return rewardData[_rewardsToken].rewardRate * rewardData[_rewardsToken].rewardsDuration;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function setRewardsDistributor(address _rewardsToken, address _rewardsDistributor)\n        external\n        onlyOwner\n    {\n        rewardData[_rewardsToken].rewardsDistributor = _rewardsDistributor;\n    }\n\n    function stake(uint256 amount) external nonReentrant whenNotPaused updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply = _totalSupply + amount;\n        _balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function stakeFor(address _staker, uint256 _amount)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        updateReward(_staker)\n        onlyOperator\n    {\n        require(_amount > 0, \"CreditPool: Cannot stake 0\");\n        _totalSupply += _amount;\n        _balances[_staker] += _amount;\n        stakingToken.safeTransferFrom(_staker, address(this), _amount);\n        emit Staked(_staker, _amount);\n    }\n\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[msg.sender][_rewardsToken];\n            if (reward > 0) {\n                rewards[msg.sender][_rewardsToken] = 0;\n                IERC20Upgradeable(_rewardsToken).safeTransfer(msg.sender, reward);\n                emit RewardPaid(msg.sender, _rewardsToken, reward);\n            }\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(address _rewardsToken, uint256 reward)\n        external\n        override\n        updateReward(address(0))\n    {\n        require(\n            rewardData[_rewardsToken].rewardsDistributor == msg.sender ||\n                creditRoles.isCreditOperator(msg.sender),\n            \"CreditPool: unauthorized caller\"\n        );\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\n        // of transactions required and ensure correctness of the reward amount\n        IERC20Upgradeable(_rewardsToken).safeTransferFrom(msg.sender, address(this), reward);\n\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\n            rewardData[_rewardsToken].rewardRate =\n                reward /\n                rewardData[_rewardsToken].rewardsDuration;\n        } else {\n            uint256 remaining = rewardData[_rewardsToken].periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardData[_rewardsToken].rewardRate;\n            rewardData[_rewardsToken].rewardRate =\n                (reward + leftover) /\n                rewardData[_rewardsToken].rewardsDuration;\n        }\n\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n        rewardData[_rewardsToken].periodFinish =\n            block.timestamp +\n            rewardData[_rewardsToken].rewardsDuration;\n\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        require(tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20Upgradeable(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(address _rewardsToken, uint256 _rewardsDuration) external {\n        require(\n            block.timestamp > rewardData[_rewardsToken].periodFinish,\n            \"Reward period still active\"\n        );\n        require(rewardData[_rewardsToken].rewardsDistributor == msg.sender);\n        require(_rewardsDuration > 0, \"Reward duration must be non-zero\");\n        rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(_rewardsToken, rewardData[_rewardsToken].rewardsDuration);\n    }\n\n    function reduceTotalCredit(uint256 _amountToAdd) external override onlyOperator {\n        totalCredit -= _amountToAdd;\n    }\n\n    function increaseTotalCredit(uint256 _amountToRemove) external override onlyOperator {\n        totalCredit += _amountToRemove;\n    }\n\n    function transferUnderwriter(address _underwriter) external {\n        require(\n            msg.sender == underwriter || creditRoles.isCreditOperator(msg.sender),\n            \"CreditPool: unauthorized\"\n        );\n        underwriter = _underwriter;\n    }\n\n    function getUnderwriter() external view override returns (address) {\n        return underwriter;\n    }\n\n    function getTotalCredit() external view override returns (uint256) {\n        return totalCredit;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address token = rewardTokens[i];\n            rewardData[token].rewardPerTokenStored = rewardPerToken(token);\n            rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);\n            if (account != address(0)) {\n                rewards[account][token] = earned(account, token);\n                userRewardPerTokenPaid[account][token] = rewardData[token].rewardPerTokenStored;\n            }\n        }\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(creditRoles.isCreditOperator(msg.sender), \"CreditPool: Caller must be an operator\");\n        _;\n    }\n\n    modifier onlyOwnerOrUnderwriter() {\n        require(\n            msg.sender == owner() || creditRoles.isUnderwriter(msg.sender),\n            \"CreditPool: Caller must be an underwriter\"\n        );\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);\n    event RewardsDurationUpdated(address token, uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/Credit/CreditRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./interface/ICreditRequest.sol\";\nimport \"./interface/ICreditRoles.sol\";\nimport \"./interface/ICreditManager.sol\";\nimport \"../Network/interface/ICIP36.sol\";\n\ncontract CreditRequest is OwnableUpgradeable, PausableUpgradeable, ICreditRequest {\n    /* ========== CONSTANTS ========== */\n\n    uint32 private constant MAX_PPM = 1000000;\n\n    /* ========== STATE VARIABLES ========== */\n\n    ICreditRoles public creditRoles;\n    ICreditManager public creditManager;\n    // network => member => CreditRequest\n    mapping(address => mapping(address => CreditRequest)) public requests;\n\n    /* ========== INITIALIZER ========== */\n\n    function initialize(address _creditRoles, address _creditManager) external initializer {\n        creditRoles = ICreditRoles(_creditRoles);\n        creditManager = ICreditManager(_creditManager);\n        __Pausable_init();\n        __Ownable_init();\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    function createRequest(\n        address _network,\n        address _networkMember,\n        uint256 _creditLimit\n    ) public override onlyValidRequester(_network, _networkMember) {\n        require(\n            requests[_network][_networkMember].creditLimit == 0,\n            \"CreditRequest: Request already exists\"\n        );\n        uint256 creditBalance = ICIP36(_network).creditBalanceOf(_networkMember);\n        require(\n            creditBalance <= _creditLimit,\n            \"CreditRequest: provided credit limit is less than current limit\"\n        );\n        bool approved = creditRoles.isRequestOperator(msg.sender);\n        requests[_network][_networkMember] = CreditRequest(approved, false, _creditLimit);\n        emit CreditRequestCreated(_network, _networkMember, msg.sender, _creditLimit, approved);\n    }\n\n    function approveRequest(address _network, address _networkMember)\n        external\n        override\n        onlyRequestOperator\n    {\n        require(\n            !requests[_network][_networkMember].approved,\n            \"CreditRequest: request already approved\"\n        );\n        require(\n            requests[_network][_networkMember].creditLimit != 0,\n            \"CreditRequest: Request does not exist\"\n        );\n        requests[_network][_networkMember].approved = true;\n        emit CreditRequestUpdated(\n            _network,\n            _networkMember,\n            requests[_network][_networkMember].creditLimit,\n            true\n        );\n    }\n\n    function acceptRequest(\n        address _network,\n        address _networkMember,\n        address _pool\n    ) external onlyUnderwriter {\n        require(\n            requests[_network][_networkMember].approved,\n            \"CreditRequest: request is not approved\"\n        );\n        CreditRequest memory request = requests[_network][_networkMember];\n        uint256 curCreditLimit = ICIP36(_network).creditLimitOf(_networkMember);\n        address underwriter = creditManager.getCreditLineUnderwriter(_network, _networkMember);\n\n        if (underwriter == address(0)) {\n            creditManager.createCreditLine(_networkMember, _pool, request.creditLimit, _network);\n        } else if (request.unstaking) {\n            require(msg.sender != underwriter, \"CreditRequest: Cannot accept own unstake request\");\n            creditManager.swapCreditLinePool(_network, _networkMember, _pool);\n        } else {\n            require(\n                request.creditLimit > curCreditLimit,\n                \"CreditRequest: request limit is less than current limit\"\n            );\n            require(msg.sender == underwriter, \"CreditRequest: Unauthorized to extend credit line\");\n            creditManager.extendCreditLine(_network, _networkMember, request.creditLimit);\n        }\n        emit CreditRequestRemoved(_network, _networkMember);\n        delete requests[_network][_networkMember];\n    }\n\n    function createAndAcceptRequest(\n        address _network,\n        address _networkMember,\n        uint256 _creditLimit,\n        address _pool\n    ) external onlyUnderwriter onlyRequestOperator {\n        uint256 curCreditLimit = ICIP36(_network).creditLimitOf(_networkMember);\n        require(\n            _creditLimit > curCreditLimit,\n            \"CreditRequest: New credit limit must be greater than current credit limit\"\n        );\n        address underwriter = creditManager.getCreditLineUnderwriter(_network, _networkMember);\n        if (underwriter == address(0)) {\n            creditManager.createCreditLine(_networkMember, _pool, _creditLimit, _network);\n        } else {\n            creditManager.extendCreditLine(_network, _networkMember, _creditLimit);\n        }\n    }\n\n    function requestUnstake(address _network, address _networkMember) external {\n        address underwriter = creditManager.getCreditLineUnderwriter(_network, _networkMember);\n        require(\n            msg.sender == underwriter,\n            \"CreditRequest: Sender must be network member's underwriter\"\n        );\n        CreditRequest storage creditRequest = requests[_network][_networkMember];\n        require(!creditRequest.unstaking, \"CreditRequest: Unstake Request already exists\");\n        requests[_network][_networkMember] = CreditRequest(true, true, 0);\n        emit UnstakeRequestCreated(_network, _networkMember);\n    }\n\n    function updateRequestLimit(\n        address _network,\n        address _networkMember,\n        uint256 _creditLimit,\n        bool _approved\n    ) external override onlyValidRequester(_network, _networkMember) {\n        require(\n            requests[_network][_networkMember].creditLimit > 0,\n            \"CreditRequest: request does not exist\"\n        );\n        CreditRequest storage creditRequest = requests[_network][_networkMember];\n        creditRequest.creditLimit = _creditLimit;\n        creditRequest.approved = _approved;\n        emit CreditRequestUpdated(_network, _networkMember, _creditLimit, _approved);\n    }\n\n    function deleteRequest(address _network, address _networkMember)\n        external\n        override\n        onlyValidRequester(_network, _networkMember)\n    {\n        delete requests[_network][_networkMember];\n        emit CreditRequestRemoved(_network, _networkMember);\n    }\n\n    /* ========== VIEWS ========== */\n\n    function verifyCreditLineExpiration(\n        address _network,\n        address _networkMember,\n        uint256 _transactionValue\n    ) external override {\n        bool creditLineExpired = creditManager.isCreditLineExpired(_network, _networkMember);\n        uint256 senderBalance = IERC20Upgradeable(_network).balanceOf(_networkMember);\n        bool usingCreditBalance = _transactionValue > senderBalance;\n\n        if (usingCreditBalance && creditLineExpired) {\n            require(\n                !requests[_network][_networkMember].unstaking,\n                \"CreditFeeManager: CreditLine is expired\"\n            );\n            creditManager.renewCreditLine(_network, _networkMember);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyCreditManager() {\n        require(\n            msg.sender == address(creditManager),\n            \"CreditRequest: Only callable by CreditManager contract\"\n        );\n        _;\n    }\n\n    modifier onlyCreditOperator() {\n        require(\n            creditRoles.isCreditOperator(msg.sender),\n            \"CreditRequest: Caller must be a credit operator\"\n        );\n        _;\n    }\n\n    modifier onlyRequestOperator() {\n        require(\n            creditRoles.isRequestOperator(msg.sender),\n            \"CreditRequest: Caller must be a request operator\"\n        );\n        _;\n    }\n\n    modifier onlyUnderwriter() {\n        require(\n            creditRoles.isUnderwriter(msg.sender),\n            \"CreditRequest: Caller must be an underwriter\"\n        );\n        _;\n    }\n\n    modifier onlyValidRequester(address _network, address _networkMember) {\n        bool hasAccess = ICIP36(_network).canRequestCredit(msg.sender, _networkMember) ||\n            creditRoles.isRequestOperator(msg.sender);\n        require(hasAccess, \"CreditRequest: Caller cannot request credit on behalf of member\");\n        _;\n    }\n}\n"
    },
    "contracts/Network/interface/ICIP36.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICIP36 {\n    function creditBalanceOf(address _member) external view returns (uint256);\n\n    function creditLimitOf(address _member) external view returns (uint256);\n\n    function creditLimitLeftOf(address _member) external view returns (uint256);\n\n    function setCreditLimit(address _member, uint256 _limit) external;\n\n    function canRequestCredit(address _requester, address _member) external returns (bool);\n}\n"
    },
    "contracts/Network/NetworkRoles.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"./interface/INetworkRoles.sol\";\nimport \"./interface/ICIP36.sol\";\n\ncontract NetworkRoles is AccessControlUpgradeable, OwnableUpgradeable, INetworkRoles {\n    /* ========== STATE VARIABLES ========== */\n\n    address network;\n\n    /* ========== INITIALIZER ========== */\n\n    function initialize(address[] memory _operators) external initializer {\n        __AccessControl_init();\n        // create roles\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(\"OPERATOR\", msg.sender);\n        _setupRole(\"MEMBER\", msg.sender);\n        _setRoleAdmin(\"MEMBER\", \"OPERATOR\");\n\n        for (uint256 j = 0; j < _operators.length; j++) {\n            require(_operators[j] != address(0), \"NetworkRoles: invalid operator supplied\");\n            grantRole(\"OPERATOR\", _operators[j]);\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    function grantMember(address _member) external override onlyNetworkOperator {\n        grantRole(\"MEMBER\", _member);\n        emit MemberAdded(_member);\n    }\n\n    function grantOperator(address _operator)\n        external\n        operatorDoesNotExist(_operator)\n        notNull(_operator)\n        onlyAdmin\n    {\n        grantRole(\"OPERATOR\", _operator);\n    }\n\n    function revokeOperator(address _operator) external onlyAdmin {\n        require(_operator != owner(), \"can't remove owner operator\");\n        revokeRole(\"OPERATOR\", _operator);\n    }\n\n    function setNetwork(address _network) external onlyNetworkOperator {\n        network = _network;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isMember(address _member) external view override returns (bool) {\n        return hasRole(\"MEMBER\", _member);\n    }\n\n    function isNetworkOperator(address _operator) public view override returns (bool) {\n        return hasRole(\"OPERATOR\", _operator);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier memberExists(address _member) {\n        require(hasRole(\"MEMBER\", _member), \"NetworkRoles: member does not exist\");\n        _;\n    }\n\n    modifier operatorDoesNotExist(address _operator) {\n        require(!hasRole(\"OPERATOR\", _operator), \"NetworkRoles: operator already exists\");\n        _;\n    }\n\n    modifier onlyNetworkOperator() {\n        require(hasRole(\"OPERATOR\", msg.sender), \"NetworkRoles: operator does not exist\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"NetworkRoles: Only admin can call\");\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0), \"invalid operator address\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/Network/interface/INetworkRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface INetworkRoles {\n    event MemberAdded(address member);\n\n    function isMember(address _member) external view returns (bool);\n\n    function isNetworkOperator(address _operator) external view returns (bool);\n\n    function grantMember(address _member) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Network/RUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"./ERC2771ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/metatx/MinimalForwarder.sol\";\nimport \"./CIP36.sol\";\nimport \"./interface/INetworkRoles.sol\";\nimport \"../Credit/interface/ICreditFeeManager.sol\";\nimport \"../Credit/interface/ICreditRoles.sol\";\nimport \"hardhat/console.sol\";\n\ncontract RUSD is CIP36, PausableUpgradeable, ERC2771ContextUpgradeable {\n    /*\n     *  Storage\n     */\n    INetworkRoles public networkRoles;\n    ICreditRoles public creditRoles;\n    ICreditFeeManager public feeManager;\n\n    modifier onlyAuthorized() override {\n        require(\n            networkRoles.isNetworkOperator(msg.sender) ||\n                creditRoles.isCreditOperator(msg.sender) ||\n                msg.sender == owner(),\n            \"Unauthorized caller\"\n        );\n        _;\n    }\n\n    modifier onlyRegistered(address _from, address _to) {\n        require(networkRoles.isMember(_from), \"Sender is not network member\");\n        require(networkRoles.isMember(_to), \"Recipient is not network member\");\n        _;\n    }\n\n    modifier onlyNetworkOperator() {\n        require(networkRoles.isNetworkOperator(msg.sender), \"Caller is not network operator\");\n        _;\n    }\n\n    function initializeRUSD(\n        address _creditRoles,\n        address _feeManager,\n        address _networkRoles,\n        address _forwarder\n    ) external virtual initializer {\n        creditRoles = ICreditRoles(_creditRoles);\n        feeManager = ICreditFeeManager(_feeManager);\n        networkRoles = INetworkRoles(_networkRoles);\n        CIP36.initialize(\"rUSD\", \"rUSD\");\n        __Pausable_init();\n        __ERC2771ContextUpgradeable_init(_forwarder);\n        _pause();\n    }\n\n    /*\n     *  Overrides\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override onlyRegistered(_from, _to) {\n        if (!paused()) {\n            feeManager.collectFees(address(this), _from, _amount);\n        }\n        super._transfer(_from, _to, _amount);\n    }\n\n    function bulkTransfer(address[] memory _to, uint256[] memory _values) external {\n        require(_to.length == _values.length, \"RUSD: invalid input\");\n        for (uint256 i = 0; i < _to.length; i++) {\n            _transfer(msg.sender, _to[i], _values[i]);\n        }\n    }\n\n    function canRequestCredit(address _requester, address _member)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _requester == _member || networkRoles.isNetworkOperator(_requester);\n    }\n\n    function pause() public onlyAuthorized {\n        _pause();\n    }\n\n    function unpause() public onlyAuthorized {\n        _unpause();\n    }\n\n    function _msgSender()\n        internal\n        view\n        override(ERC2771ContextUpgradeable, ContextUpgradeable)\n        returns (address)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        override(ERC2771ContextUpgradeable, ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n}\n"
    },
    "contracts/Network/ERC2771ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n */\nabstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {\n    address private _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __ERC2771ContextUpgradeable_init(address trustedForwarder) internal onlyInitializing {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/metatx/MinimalForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (metatx/MinimalForwarder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/ECDSA.sol\";\nimport \"../utils/cryptography/draft-EIP712.sol\";\n\n/**\n * @dev Simple minimal forwarder to be used together with an ERC2771 compatible contract. See {ERC2771Context}.\n */\ncontract MinimalForwarder is EIP712 {\n    using ECDSA for bytes32;\n\n    struct ForwardRequest {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint256 nonce;\n        bytes data;\n    }\n\n    bytes32 private constant _TYPEHASH =\n        keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");\n\n    mapping(address => uint256) private _nonces;\n\n    constructor() EIP712(\"MinimalForwarder\", \"0.0.1\") {}\n\n    function getNonce(address from) public view returns (uint256) {\n        return _nonces[from];\n    }\n\n    function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\n        address signer = _hashTypedDataV4(\n            keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\n        ).recover(signature);\n        return _nonces[req.from] == req.nonce && signer == req.from;\n    }\n\n    function execute(ForwardRequest calldata req, bytes calldata signature)\n        public\n        payable\n        returns (bool, bytes memory)\n    {\n        require(verify(req, signature), \"MinimalForwarder: signature does not match request\");\n        _nonces[req.from] = req.nonce + 1;\n\n        (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(\n            abi.encodePacked(req.data, req.from)\n        );\n\n        // Validate that the relayer has sent enough gas for the call.\n        // See https://ronan.eth.link/blog/ethereum-gas-dangers/\n        if (gasleft() <= req.gas / 63) {\n            // We explicitly trigger invalid opcode to consume all gas and bubble-up the effects, since\n            // neither revert or assert consume all gas since Solidity 0.8.0\n            // https://docs.soliditylang.org/en/v0.8.0/control-structures.html#panic-via-assert-and-error-via-require\n            assembly {\n                invalid()\n            }\n        }\n\n        return (success, returndata);\n    }\n}\n"
    },
    "contracts/Network/CIP36.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n\ncontract CIP36 is OwnableUpgradeable, ERC20BurnableUpgradeable {\n    using ExtraMath for *;\n\n    struct Member {\n        uint128 creditBalance;\n        uint128 creditLimit;\n    }\n\n    mapping(address => Member) private _members;\n\n    event CreditLimitUpdate(address member, uint256 limit);\n\n    function initialize(string memory name_, string memory symbol_) public virtual initializer {\n        __ERC20_init(name_, symbol_);\n        __Ownable_init();\n    }\n\n    modifier onlyAuthorized() virtual {\n        require(msg.sender == owner(), \"invalid caller address\");\n        _;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    function creditBalanceOf(address _member) public view returns (uint256) {\n        return _members[_member].creditBalance;\n    }\n\n    function creditLimitOf(address _member) external view returns (uint256) {\n        return _members[_member].creditLimit;\n    }\n\n    function creditLimitLeftOf(address _member) public view returns (uint256) {\n        Member memory _localMember = _members[_member];\n        if (_localMember.creditBalance >= _localMember.creditLimit) {\n            return 0;\n        }\n        return _localMember.creditLimit - _localMember.creditBalance;\n    }\n\n    function setCreditLimit(address _member, uint256 _limit) public virtual onlyAuthorized {\n        _members[_member].creditLimit = _limit.toUInt128();\n        emit CreditLimitUpdate(_member, _limit);\n    }\n\n    function canRequestCredit(\n        address, /*_requester*/\n        address /*_member*/\n    ) public virtual returns (bool) {\n        return true;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override {\n        _beforeTransfer(_from, _amount);\n        super._transfer(_from, _to, _amount);\n        _afterTransfer(_to, _amount);\n    }\n\n    function _beforeTransfer(address _from, uint256 _amount) private {\n        uint256 _balanceFrom = balanceOf(_from);\n        if (_balanceFrom >= _amount) {\n            return;\n        }\n\n        Member memory _memberFrom = _members[_from];\n        uint256 _missingBalance = _amount - _balanceFrom;\n        uint256 _creditLeft = creditLimitLeftOf(_from);\n        require(_creditLeft >= _missingBalance, \"Insufficient credit\");\n        _members[_from].creditBalance = (_memberFrom.creditBalance + _missingBalance).toUInt128();\n        _mint(_from, _missingBalance);\n    }\n\n    function _afterTransfer(address _to, uint256 _amount) private {\n        Member memory _memberTo = _members[_to];\n        uint256 _repay = Math.min(_memberTo.creditBalance, _amount);\n        if (_repay == 0) {\n            return;\n        }\n        _members[_to].creditBalance = (_memberTo.creditBalance - _repay).toUInt128();\n        _burn(_to, _repay);\n    }\n}\n\nlibrary ExtraMath {\n    function toUInt128(uint256 _a) internal pure returns (uint128) {\n        require(_a < 2**128 - 1, \"uin128 overflow\");\n        return uint128(_a);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/Credit/CreditRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./interface/ICreditRoles.sol\";\n\ncontract CreditRoles is AccessControlUpgradeable, OwnableUpgradeable, ICreditRoles {\n    /* ========== INITIALIZER ========== */\n\n    function initialize(address[] memory _operators) external initializer {\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(\"OPERATOR\", msg.sender);\n        _setupRole(\"UNDERWRITER\", msg.sender);\n        _setupRole(\"NETWORK\", msg.sender);\n        _setupRole(\"REQUEST\", msg.sender);\n        _setRoleAdmin(\"UNDERWRITER\", \"OPERATOR\");\n        _setRoleAdmin(\"NETWORK\", \"OPERATOR\");\n        _setRoleAdmin(\"REQUEST\", \"OPERATOR\");\n        for (uint256 j = 0; j < _operators.length; j++) {\n            require(_operators[j] != address(0));\n            grantRole(\"OPERATOR\", _operators[j]);\n        }\n        emit UnderwriterAdded(msg.sender);\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    function grantOperator(address _operator)\n        external\n        operatorDoesNotExist(_operator)\n        notNull(_operator)\n        onlyAdmin\n    {\n        grantRole(\"OPERATOR\", _operator);\n    }\n\n    function revokeOperator(address _operator) external onlyAdmin {\n        require(_operator != owner(), \"can't remove owner operator\");\n        revokeRole(\"OPERATOR\", _operator);\n    }\n\n    function grantUnderwriter(address _underwriter)\n        external\n        override\n        onlyRole(\"OPERATOR\")\n        underwriterDoesNotExist(_underwriter)\n    {\n        grantRole(\"UNDERWRITER\", _underwriter);\n        emit UnderwriterAdded(_underwriter);\n    }\n\n    function revokeUnderwriter(address _underwriter)\n        external\n        override\n        onlyRole(\"OPERATOR\")\n        underwriterExists(_underwriter)\n    {\n        revokeRole(\"UNDERWRITER\", _underwriter);\n        emit UnderwriterRemoved(_underwriter);\n    }\n\n    function grantNetwork(address _network) external override onlyRole(\"OPERATOR\") {\n        require(!hasRole(\"NETWORK\", _network) && _network != address(0), \"invalid network\");\n        grantRole(\"NETWORK\", _network);\n    }\n\n    function revokeNetwork(address _network)\n        external\n        override\n        onlyRole(\"OPERATOR\")\n        networkExists(_network)\n    {\n        revokeRole(\"NETWORK\", _network);\n    }\n\n    function grantRequestOperator(address _requestOperator) external override onlyRole(\"OPERATOR\") {\n        require(\n            !hasRole(\"REQUEST\", _requestOperator) && _requestOperator != address(0),\n            \"invalid request\"\n        );\n        grantRole(\"REQUEST\", _requestOperator);\n    }\n\n    function revokeRequestOperator(address _requestOperator)\n        external\n        override\n        onlyRole(\"OPERATOR\")\n        requestOperatorExists(_requestOperator)\n    {\n        revokeRole(\"REQUEST\", _requestOperator);\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isUnderwriter(address _underwriter) external view override returns (bool) {\n        return hasRole(\"UNDERWRITER\", _underwriter) || hasRole(\"OPERATOR\", _underwriter);\n    }\n\n    function isCreditOperator(address _operator) external view override returns (bool) {\n        return hasRole(\"OPERATOR\", _operator);\n    }\n\n    function isNetwork(address _network) external view override returns (bool) {\n        return hasRole(\"NETWORK\", _network) || hasRole(\"OPERATOR\", _network);\n    }\n\n    function isRequestOperator(address _operator) external view override returns (bool) {\n        return hasRole(\"REQUEST\", _operator) || hasRole(\"OPERATOR\", _operator);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier underwriterExists(address _underwriter) {\n        require(hasRole(\"UNDERWRITER\", _underwriter), \"NetworkRoles: underwriter does not exist\");\n        _;\n    }\n\n    modifier underwriterDoesNotExist(address _underwriter) {\n        require(!hasRole(\"UNDERWRITER\", _underwriter), \"NetworkRoles: underwriter already exists\");\n        _;\n    }\n\n    modifier networkExists(address _network) {\n        require(hasRole(\"NETWORK\", _network), \"NetworkRoles: network does not exist\");\n        _;\n    }\n\n    modifier requestOperatorExists(address _requestOperator) {\n        require(\n            hasRole(\"REQUEST\", _requestOperator),\n            \"NetworkRoles: request operator does not exist\"\n        );\n        _;\n    }\n\n    modifier operatorDoesNotExist(address _operator) {\n        require(!hasRole(\"OPERATOR\", _operator), \"CreditRoles: operator already exists\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"NetworkRoles: Only admin can call\");\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0), \"invalid operator address\");\n        _;\n    }\n}\n"
    },
    "contracts/SOURCE/TokenClaimV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./IERC20SOUL.sol\";\n\n/// @title TokenClaimV2 - This contract enables the storage of\n/// locked (specified by the ERC20SOUL standard) and unlocked\n/// tokens by a beneficiary address. This implementation also\n/// allows the owner to revoke a given claim in the case that\n/// a beneficiary does not or is unable to claim.\n/// @author Bridger Zoske - bridger@resourcenetwork.co\ncontract TokenClaimV2 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    struct Claim {\n        uint256 unlockedAmount;\n        IERC20SOUL.Lock lock;\n        bool released;\n    }\n\n    // address of the ERC20 token\n    IERC20SOUL private _token;\n    mapping(address => Claim) public claims;\n    uint256 public totalClaimable;\n\n    event Released(Claim claim);\n    event NewClaimAdded(Claim claim);\n    event ClaimUpdated(Claim claim);\n\n    /**\n     * @dev Reverts if the address is null.\n     */\n    modifier notNull(address _address) {\n        require(_address != address(0), \"Invalid address\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if the claim does not exist or has been released.\n     */\n    modifier onlyIfClaimNotReleased(address beneficiary) {\n        require(getClaimTotal(beneficiary) != 0, \"TokenClaim: Claim does not exist\");\n        require(claims[beneficiary].released == false, \"TokenClaim: Claim has been released\");\n        _;\n    }\n\n    /**\n     * @dev Creates a claim contract.\n     * @param token_ address of the ERC20 token contract\n\n     */\n    function initialize(address token_) external virtual initializer {\n        require(token_ != address(0x0));\n        __Ownable_init();\n        _token = IERC20SOUL(token_);\n    }\n\n    /**\n     * @dev Returns the address of the ERC20 token managed by the claim contract.\n     */\n    function getToken() external view returns (address) {\n        return address(_token);\n    }\n\n    /**\n     * @notice Creates a new claim for a beneficiary.\n     * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n     * @param _unlockedAmount total unlocked amount in claim\n     * @param _lock lock structure for locked tokens in claim\n     */\n    function addClaim(\n        address _beneficiary,\n        uint256 _unlockedAmount,\n        IERC20SOUL.Lock calldata _lock\n    ) public notNull(_beneficiary) onlyOwner {\n        uint256 totalAmount = _unlockedAmount + _lock.totalAmount;\n        require(\n            getWithdrawableAmount() >= totalAmount,\n            \"TokenClaim: cannot create claim because not sufficient tokens\"\n        );\n        require(totalAmount > 0, \"TokenClaim: amount must be > 0\");\n\n        if (_lock.totalAmount > 0) {\n            validLock(_lock);\n        }\n\n        Claim storage _claim = claims[_beneficiary];\n\n        if (getClaimTotal(_beneficiary) == 0) {\n            _claim.lock = _lock;\n            _claim.unlockedAmount = _unlockedAmount;\n            emit NewClaimAdded(_claim);\n        } else {\n            _claim.lock.totalAmount += _lock.totalAmount;\n            for (uint256 i = 0; i < _lock.schedules.length; i++) {\n                _claim.lock.schedules.push(\n                    IERC20SOUL.Schedule(\n                        _lock.schedules[i].amount,\n                        _lock.schedules[i].expirationBlock\n                    )\n                );\n            }\n            _claim.unlockedAmount += _unlockedAmount;\n            emit ClaimUpdated(_claim);\n        }\n        _claim.released = false;\n        totalClaimable += totalAmount;\n    }\n\n    function validLock(IERC20SOUL.Lock calldata _lock) internal view {\n        require(_lock.totalAmount > 0, \"Invalid Lock amount\");\n        uint256 lockTotal;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lockTotal += _lock.schedules[i].amount;\n            require(\n                _lock.schedules[i].expirationBlock > block.timestamp + _token.getMinLockTime(),\n                \"Lock schedule does not meet minimum\"\n            );\n            require(\n                _lock.schedules[i].expirationBlock < block.timestamp + _token.getMaxLockTime(),\n                \"Lock schedule does not meet maximum\"\n            );\n        }\n        require(lockTotal == _lock.totalAmount, \"Invalid Lock\");\n    }\n\n    /**\n     * @notice Revokes the claim for given beneficiary\n     * @param beneficiary address of claim owner\n     */\n    function revoke(address beneficiary) public onlyOwner onlyIfClaimNotReleased(beneficiary) {\n        totalClaimable -= getClaimTotal(beneficiary);\n        delete claims[beneficiary];\n    }\n\n    /**\n     * @notice Withdraw the specified amount if possible.\n     * @param amount the amount to withdraw\n     */\n    function withdraw(uint256 amount) public nonReentrant onlyOwner {\n        require(getWithdrawableAmount() >= amount, \"TokenClaim: not enough withdrawable funds\");\n        _token.transfer(owner(), amount);\n    }\n\n    /**\n     * @notice claim tokens\n     */\n    function claim() public nonReentrant onlyIfClaimNotReleased(msg.sender) {\n        Claim storage _claim = claims[msg.sender];\n        uint256 deleteOffset;\n        uint256 schedulesLength = _claim.lock.schedules.length;\n        for (uint256 i = 0; i < schedulesLength; i++) {\n            uint256 index = i - deleteOffset;\n            // lock schedule is expired so add locked amount to unlocked amount and remove schedule\n            if (_claim.lock.schedules[index].expirationBlock - 1 days < block.timestamp) {\n                _claim.unlockedAmount += _claim.lock.schedules[index].amount;\n                _claim.lock.totalAmount -= _claim.lock.schedules[index].amount;\n                _claim.lock.schedules[index] = _claim.lock.schedules[\n                    _claim.lock.schedules.length - 1\n                ];\n                _claim.lock.schedules.pop();\n                deleteOffset++;\n            }\n        }\n        if (_claim.unlockedAmount > 0) {\n            _token.transfer(msg.sender, _claim.unlockedAmount);\n        }\n        if (_claim.lock.totalAmount > 0) {\n            _token.transferWithLock(msg.sender, _claim.lock);\n        }\n        uint256 totalAmount = getClaimTotal(msg.sender);\n        delete claims[msg.sender];\n        _claim.released = true;\n        totalClaimable -= totalAmount;\n        emit Released(_claim);\n    }\n\n    /**\n     * @dev Returns the amount of tokens that can be withdrawn by the owner.\n     * @return the amount of tokens\n     */\n    function getWithdrawableAmount() public view returns (uint256) {\n        return _token.balanceOf(address(this)) - totalClaimable;\n    }\n\n    /**\n     * @dev Returns the amount of tokens that can be withdrawn by the owner.\n     * @return the amount of tokens\n     */\n    function getClaimTotal(address beneficiary) public view returns (uint256) {\n        Claim memory _claim = claims[beneficiary];\n        return _claim.unlockedAmount + _claim.lock.totalAmount;\n    }\n\n    /**\n     * @dev Returns the lock schedule of a given beneficiary.\n     * @return the lock schedule object of a claim\n     */\n    function getClaimLockSchedule(address beneficiary)\n        external\n        view\n        returns (IERC20SOUL.Schedule[] memory)\n    {\n        return claims[beneficiary].lock.schedules;\n    }\n}\n"
    },
    "contracts/SOURCE/IERC20SOUL.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title ERC20SOUL - An ERC20 extension that enables the transfer of\n/// tokens alongside locking periods that can be applied to subsets of\n/// the total transfer amount. This implementation also allows the owner\n/// to specify staking contract addresses that locked addresses can \n/// interact with.\n/// @author Bridger Zoske - <bridger@resourcenetwork.co>\ninterface IERC20SOUL {\n    /*\n     *  Events\n     */\n    event LockedTransfer(\n        Lock lock,\n        address sender,\n        address recipient\n    );\n\n    event LockExpired(\n        address owner,\n        Lock lock\n    );\n\n    event LockScheduleExpired(\n        address owner,\n        Lock lock\n    );\n\n    struct Lock {\n        uint256 totalAmount;\n        uint256 amountStaked;\n        Schedule[] schedules;\n    }\n\n    struct Schedule {\n        uint256 amount;\n        uint256 expirationBlock;\n    }\n\n    /// @dev external function to get minimum lock time\n    function getMinLockTime() external view returns (uint256);\n\n    /// @dev external function to get maximum lock time\n    function getMaxLockTime() external view returns (uint256);\n\n    /// @dev external function to get maximum number of schedules per lock\n    function getMaxSchedules() external view returns (uint256);\n\n    /// @dev Creates a valid recipient lock after transfering tokens\n    /// @param _to address to send tokens to\n    /// @param _lock valid lock data associated with transfer\n    function transferWithLock(address _to, Lock calldata _lock) external;\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "contracts/SOURCE/TokenClaim.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./IERC20SOUL.sol\";\n\n/// @title TokenClaim - This contract enables the storage of\n/// locked (specified by the ERC20SOUL standard) and unlocked\n/// tokens by a beneficiary address. This implementation also \n/// allows the owner to revoke a given claim in the case that\n/// a beneficiary does not or is unable to claim.\n/// @author Bridger Zoske - bridger@resourcenetwork.co\ncontract TokenClaim is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n\n    struct Claim {\n        uint256 unlockedAmount;\n        IERC20SOUL.Lock lock;\n        bool released;\n    }\n\n    // address of the ERC20 token\n    IERC20SOUL private _token;\n    mapping(address => Claim) public claims;\n    uint256 public totalClaimable;\n    \n    event Released(Claim claim);\n    event NewClaimAdded(Claim claim);\n    event ClaimUpdated(Claim claim);\n\n    /**\n    * @dev Reverts if the address is null.\n    */\n    modifier notNull(address _address) {\n        require(_address != address(0), \"Invalid address\");\n        _;\n    }\n\n    /**\n    * @dev Reverts if the claim does not exist or has been released.\n    */\n    modifier onlyIfClaimNotReleased(address beneficiary) {\n        require(getClaimTotal(beneficiary) != 0, \"TokenClaim: Claim does not exist\");\n        require(claims[beneficiary].released == false, \"TokenClaim: Claim has been released\");\n        _;\n    }\n\n    /**\n     * @dev Creates a claim contract.\n     * @param token_ address of the ERC20 token contract\n\n     */\n    function initialize(address token_) external virtual initializer {\n        require(token_ != address(0x0));\n        __Ownable_init();\n        _token = IERC20SOUL(token_);\n    }\n\n    /**\n    * @dev Returns the address of the ERC20 token managed by the claim contract.\n    */\n    function getToken()\n    external\n    view\n    returns(address){\n        return address(_token);\n    }\n\n    /**\n    * @notice Creates a new claim for a beneficiary.\n    * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n    * @param _unlockedAmount total unlocked amount in claim\n    * @param _lock lock structure for locked tokens in claim\n    */\n    function addClaim(\n        address _beneficiary,\n        uint256 _unlockedAmount,\n        IERC20SOUL.Lock calldata _lock\n    )\n        public\n        notNull(_beneficiary)\n        onlyOwner{\n        uint256 totalAmount = _unlockedAmount + _lock.totalAmount;\n        require(\n            getWithdrawableAmount() >= totalAmount,\n            \"TokenClaim: cannot create claim because not sufficient tokens\"\n        );\n        require(totalAmount > 0, \"TokenClaim: amount must be > 0\");\n\n        if (_lock.totalAmount > 0) {\n            validLock(_lock);\n        }\n\n        Claim storage _claim = claims[_beneficiary];\n\n        if (getClaimTotal(_beneficiary) == 0) {\n            _claim.lock = _lock;\n            _claim.unlockedAmount = _unlockedAmount;\n            emit NewClaimAdded(_claim);\n        } else {\n            _claim.lock.totalAmount += _lock.totalAmount;\n            for (uint256 i = 0; i < _lock.schedules.length; i++) {\n                _claim.lock.schedules.push(\n                    IERC20SOUL.Schedule(\n                        _lock.schedules[i].amount, \n                        _lock.schedules[i].expirationBlock\n                ));\n            }            \n            _claim.unlockedAmount += _unlockedAmount;\n            emit ClaimUpdated(_claim);\n        }\n        _claim.released = false;\n        totalClaimable += totalAmount;\n    }\n\n    function validLock(IERC20SOUL.Lock calldata _lock) internal view {\n        require(_lock.totalAmount > 0, \"Invalid Lock amount\");\n        uint256 lockTotal;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lockTotal += _lock.schedules[i].amount;\n            require(_lock.schedules[i].expirationBlock > \n                block.timestamp + _token.getMinLockTime(), \"Lock schedule does not meet minimum\");\n            require(_lock.schedules[i].expirationBlock < \n                block.timestamp + _token.getMaxLockTime(), \"Lock schedule does not meet maximum\");\n        }\n        require(lockTotal == _lock.totalAmount, \"Invalid Lock\");\n    }\n\n    /**\n    * @notice Revokes the claim for given beneficiary\n    * @param beneficiary address of claim owner\n    */\n    function revoke(address beneficiary)\n        public\n        onlyOwner\n        onlyIfClaimNotReleased(beneficiary){\n        totalClaimable -= getClaimTotal(beneficiary);\n        delete claims[beneficiary];\n    }\n\n    /**\n    * @notice Withdraw the specified amount if possible.\n    * @param amount the amount to withdraw\n    */\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        onlyOwner{\n        require(getWithdrawableAmount() >= amount, \"TokenClaim: not enough withdrawable funds\");\n        _token.transfer(owner(), amount);\n    }\n\n    /**\n    * @notice claim tokens\n    */\n    function claim()\n        public\n        nonReentrant\n        onlyIfClaimNotReleased(msg.sender) {\n        Claim storage _claim = claims[msg.sender];\n        if (_claim.unlockedAmount > 0) {\n            _token.transfer(msg.sender, _claim.unlockedAmount);\n        }\n        uint256 totalAmount = getClaimTotal(msg.sender);\n        if (_claim.lock.totalAmount > 0) {\n            _token.transferWithLock(msg.sender, _claim.lock);\n        }\n        delete claims[msg.sender];\n        _claim.released = true;\n        totalClaimable -= totalAmount;\n        emit Released(_claim);\n    }\n\n    /**\n    * @dev Returns the amount of tokens that can be withdrawn by the owner.\n    * @return the amount of tokens\n    */\n    function getWithdrawableAmount()\n        public\n        view\n        returns(uint256){\n        return _token.balanceOf(address(this)) - totalClaimable;\n    }\n\n     /**\n    * @dev Returns the amount of tokens that can be withdrawn by the owner.\n    * @return the amount of tokens\n    */\n    function getClaimTotal(address beneficiary)\n        public\n        view\n        returns(uint256){\n        Claim memory _claim = claims[beneficiary];\n        return _claim.unlockedAmount + _claim.lock.totalAmount;\n    }\n\n         /**\n    * @dev Returns the lock schedule of a given beneficiary.\n    * @return the lock schedule object of a claim\n    */\n    function getClaimLockSchedule(address beneficiary)\n        external\n        view\n        returns(IERC20SOUL.Schedule[] memory){\n        return claims[beneficiary].lock.schedules;\n    }\n}"
    },
    "contracts/SOURCE/SourceTokenV3.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20SOULV3.sol\";\n\ncontract SourceTokenV3 is ERC20SOULV3 {\n    function initialize(uint256 initialSupply, address[] calldata stakableContracts)\n        external\n        virtual\n        initializer\n    {\n        ERC20SOULV3.initializeERC20SOUL(\"Source\", \"SOURCE\", initialSupply, stakableContracts);\n    }\n}\n"
    },
    "contracts/SOURCE/ERC20SOULV3.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title ERC20SOUL - An ERC20 extension that enables the transfer of\n/// tokens alongside locking periods that can be applied to subsets of\n/// the total transfer amount. This implementation also allows the owner\n/// to specify staking contract addresses that locked addresses can\n/// interact with.\n/// @author Bridger Zoske - bridger@resourcenetwork.co\ncontract ERC20SOULV3 is ERC20Upgradeable, OwnableUpgradeable {\n    /*\n     *  Events\n     */\n    event LockedTransfer(address sender, address recipient);\n\n    event LockExpired(address owner);\n\n    event LockScheduleExpired(address owner);\n\n    event LockReturned(address owner, uint256 amount);\n\n    /*\n     *  Storage\n     */\n    mapping(address => bool) public isStakeableContract;\n    mapping(address => Lock) public locks;\n    uint256 public minLockTime;\n    uint256 public maxLockTime;\n    uint256 public maxSchedules;\n    uint256 public totalLocked;\n    bool private _upgradeV2;\n\n    struct Lock {\n        uint256 totalAmount;\n        uint256 amountStaked;\n        Schedule[] schedules;\n    }\n\n    struct Schedule {\n        uint256 amount;\n        uint256 expirationBlock;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier validLock(Lock calldata _lock) {\n        require(_lock.totalAmount > 0, \"Invalid Lock amount\");\n        uint256 lockTotal;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lockTotal += _lock.schedules[i].amount;\n            require(\n                _lock.schedules[i].expirationBlock > block.timestamp + minLockTime,\n                \"Lock schedule does not meet minimum\"\n            );\n            require(\n                _lock.schedules[i].expirationBlock < block.timestamp + maxLockTime,\n                \"Lock schedule does not meet maximum\"\n            );\n        }\n        require(lockTotal == _lock.totalAmount, \"Invalid Lock\");\n        _;\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract initialzer sets ERC20 token data and stakeable contracts\n    /// @param name Name of ERC20 token\n    /// @param symbol Symbol of ERC20 token\n    /// @param initialSupply Initial supply of ERC20 token\n    /// @param stakeableContracts List of valid staking contracts\n    function initializeERC20SOUL(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address[] calldata stakeableContracts\n    ) public virtual initializer {\n        __ERC20_init(name, symbol);\n        __Ownable_init();\n        _mint(msg.sender, initialSupply);\n        minLockTime = 1 days;\n        maxLockTime = 1825 days;\n        maxSchedules = 260;\n        for (uint256 i = 0; i < stakeableContracts.length; i++) {\n            require(stakeableContracts[i] != address(0), \"invalid stakeable contract address\");\n            isStakeableContract[stakeableContracts[i]] = true;\n        }\n    }\n\n    /// @dev Creates a valid recipient lock after transfering tokens\n    /// @param _to address to send tokens to\n    /// @param _lock valid lock data associated with transfer\n    function transferWithLock(address _to, Lock calldata _lock) external validLock(_lock) {\n        super._transfer(msg.sender, _to, _lock.totalAmount);\n        Lock storage lock = locks[_to];\n        require(\n            lock.schedules.length + _lock.schedules.length < maxSchedules,\n            \"Maximum locks on address\"\n        );\n        lock.totalAmount += _lock.totalAmount;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lock.schedules.push(\n                Schedule(_lock.schedules[i].amount, _lock.schedules[i].expirationBlock)\n            );\n        }\n        totalLocked += _lock.totalAmount;\n        emit LockedTransfer(msg.sender, _to);\n    }\n\n    /*\n     * Internal functions\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        _updateLock(_from, _to, _amount);\n        super._transfer(_from, _to, _amount);\n    }\n\n    /// @dev internal function to update relevant lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param _amount transaction amount\n    function _updateLock(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (updateRecipientLock(_from, _to, _amount)) {\n            return;\n        }\n        updateSenderLock(_from, _to, _amount);\n    }\n\n    /// @dev internal function to update the sender's lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateSenderLock(\n        address _from,\n        address _to,\n        uint256 sendAmount\n    ) internal {\n        Lock storage senderLock = locks[_from];\n\n        // no lock on sender\n        if (senderLock.totalAmount == 0) {\n            return;\n        }\n        // staking tokens\n        if (isStakeableContract[_to]) {\n            if (senderLock.totalAmount - senderLock.amountStaked >= sendAmount) {\n                senderLock.amountStaked += sendAmount;\n            } else {\n                senderLock.amountStaked = senderLock.totalAmount;\n            }\n            return;\n        }\n\n        uint256 amountToUnlock;\n        uint256 deleteOffset;\n        uint256 totalSenderSchedules = senderLock.schedules.length;\n        for (uint256 i = 0; i < totalSenderSchedules + deleteOffset; i++) {\n            uint256 index = i - deleteOffset;\n            if (block.timestamp >= senderLock.schedules[index].expirationBlock) {\n                amountToUnlock += senderLock.schedules[index].amount;\n                senderLock.schedules[index] = senderLock.schedules[totalSenderSchedules - 1];\n                senderLock.schedules.pop();\n                deleteOffset++;\n                totalSenderSchedules--;\n                emit LockScheduleExpired(_from);\n            }\n        }\n        uint256 availableAmount = amountToUnlock +\n            super.balanceOf(_from) +\n            senderLock.amountStaked -\n            senderLock.totalAmount;\n        senderLock.totalAmount -= amountToUnlock;\n        totalLocked = totalLocked < amountToUnlock ? 0 : totalLocked -= amountToUnlock;\n        require(availableAmount >= sendAmount, \"Insufficient unlocked funds\");\n        if (senderLock.totalAmount == 0) {\n            emit LockExpired(_from);\n            delete locks[_from];\n        }\n    }\n\n    /// @dev internal function to update the recipient's lock if transaction is from stakeable contract\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateRecipientLock(\n        address _from,\n        address _to,\n        uint256 sendAmount\n    ) internal returns (bool) {\n        if (!isStakeableContract[_from]) {\n            return false;\n        }\n\n        Lock storage recipientLock = locks[_to];\n        // lock does not exist\n        if (recipientLock.totalAmount == 0) {\n            return false;\n        }\n\n        recipientLock.amountStaked = recipientLock.amountStaked >= sendAmount\n            ? recipientLock.amountStaked - sendAmount\n            : 0;\n        return true;\n    }\n\n    // ADMIN\n\n    /// @dev external function to update minimum lock time\n    /// @param _newMin new minimum locking time\n    function setMinLockTime(uint256 _newMin) external onlyOwner {\n        minLockTime = _newMin;\n    }\n\n    /// @dev external function to get minimum lock time\n    function getMinLockTime() external view returns (uint256) {\n        return minLockTime;\n    }\n\n    /// @dev external function to update maximum lock time\n    /// @param _newMax new maximum locking time\n    function setMaxLockTime(uint256 _newMax) external onlyOwner {\n        maxLockTime = _newMax;\n    }\n\n    /// @dev external function to get maximum lock time\n    function getMaxLockTime() external view returns (uint256) {\n        return maxLockTime;\n    }\n\n    /// @dev external function to update maximum number of schedules per lock\n    /// @param _newMax new maximum number of shedules per lock\n    function setMaxSchedules(uint256 _newMax) external onlyOwner {\n        maxSchedules = _newMax;\n    }\n\n    /// @dev external function to get maximum number of schedules per lock\n    function getMaxSchedules() external view returns (uint256) {\n        return maxSchedules;\n    }\n\n    /// @dev external function to add a stakeable contract\n    /// @param stakingContract address of the staking contract to be added\n    function addStakeableContract(address stakingContract) external onlyOwner {\n        require(stakingContract != address(0), \"Invalid staking address\");\n        isStakeableContract[stakingContract] = true;\n    }\n\n    /// @dev external function to remove a stakeable contract\n    /// @param stakingContract address of the staking contract to be removed\n    function removeStakeableContract(address stakingContract) external onlyOwner {\n        require(isStakeableContract[stakingContract], \"Invalid staking address\");\n        isStakeableContract[stakingContract] = false;\n    }\n\n    // WEB3 interface\n    function getLockSchedules(address owner) public view returns (Lock memory) {\n        Lock memory lock = locks[owner];\n        return lock;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return super.balanceOf(account) - lockedBalanceOf(account);\n    }\n\n    function lockedBalanceOf(address account) public view returns (uint256) {\n        Lock memory senderLock = locks[account];\n        uint256 lockedBalance;\n        for (uint256 i = 0; i < senderLock.schedules.length; i++) {\n            if (block.timestamp < senderLock.schedules[i].expirationBlock) {\n                lockedBalance += senderLock.schedules[i].amount;\n            }\n        }\n\n        return lockedBalance - senderLock.amountStaked;\n    }\n\n    function refundLockedTokensToOwner() external {\n        uint256 lockedBalance = lockedBalanceOf(msg.sender);\n        totalLocked = totalLocked < lockedBalance ? 0 : totalLocked -= lockedBalance;\n        super._transfer(msg.sender, owner(), lockedBalanceOf(msg.sender));\n        delete locks[msg.sender];\n        emit LockReturned(msg.sender, totalLocked);\n    }\n}\n"
    },
    "contracts/SOURCE/SourceTokenV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20SOULV2.sol\";\n\ncontract SourceTokenV2 is ERC20SOULV2 {\n    function initialize (\n        uint256 initialSupply,\n        address[] calldata stakableContracts) external virtual initializer {\n        ERC20SOULV2.initializeERC20SOUL(\"Source\", \"SOURCE\", initialSupply, stakableContracts);\n    }\n}"
    },
    "contracts/SOURCE/ERC20SOULV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n\n/// @title ERC20SOUL - An ERC20 extension that enables the transfer of\n/// tokens alongside locking periods that can be applied to subsets of\n/// the total transfer amount. This implementation also allows the owner\n/// to specify staking contract addresses that locked addresses can \n/// interact with.\n/// @author Bridger Zoske - bridger@resourcenetwork.co\ncontract ERC20SOULV2 is ERC20Upgradeable, OwnableUpgradeable {\n    /*\n     *  Events\n     */\n    event LockedTransfer(\n        Lock lock,\n        address sender,\n        address recipient\n    );\n\n    event LockExpired(\n        address owner,\n        Lock lock\n    );\n\n    event LockScheduleExpired(\n        address owner,\n        Lock lock\n    );\n\n    event LockReturned(address owner, uint256 amount);\n\n    /*\n     *  Storage\n     */\n    mapping (address => bool) public isStakeableContract;\n    mapping(address => Lock) public locks;\n    uint256 public minLockTime;\n    uint256 public maxLockTime;\n    uint256 public maxSchedules;\n    uint256 public totalLocked;\n    bool private _upgradeV2;\n\n    struct Lock {\n        uint256 totalAmount;\n        uint256 amountStaked;\n        Schedule[] schedules;\n    }\n\n    struct Schedule {\n        uint256 amount;\n        uint256 expirationBlock;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier validLock(Lock calldata _lock) {\n        require(_lock.totalAmount > 0, \"Invalid Lock amount\");\n        uint256 lockTotal;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lockTotal += _lock.schedules[i].amount;\n            require(_lock.schedules[i].expirationBlock > \n                block.timestamp + minLockTime, \"Lock schedule does not meet minimum\");\n            require(_lock.schedules[i].expirationBlock < \n                block.timestamp + maxLockTime, \"Lock schedule does not meet maximum\");\n        }\n        require(lockTotal == _lock.totalAmount, \"Invalid Lock\");\n        _;\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract initialzer sets ERC20 token data and stakeable contracts\n    /// @param name Name of ERC20 token\n    /// @param symbol Symbol of ERC20 token\n    /// @param initialSupply Initial supply of ERC20 token\n    /// @param stakeableContracts List of valid staking contracts \n    function initializeERC20SOUL(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address[] calldata stakeableContracts\n    ) public virtual initializer {\n        __ERC20_init(name, symbol);\n        __Ownable_init();\n        _mint(msg.sender, initialSupply);\n        minLockTime = 1 days;\n        maxLockTime = 1825 days; \n        maxSchedules = 260;\n        for (uint256 i = 0; i < stakeableContracts.length; i++) {\n            require(stakeableContracts[i] != address(0), \"invalid stakeable contract address\");\n            isStakeableContract[stakeableContracts[i]] = true;\n        }\n    }\n\n    function upgradeV2() public {\n        require (!_upgradeV2, \"ERC20SOULV2: already upgraded to V2\");\n        _upgradeV2 = true;\n        totalLocked = 1500000 ether;\n    }\n\n    /// @dev Creates a valid recipient lock after transfering tokens\n    /// @param _to address to send tokens to\n    /// @param _lock valid lock data associated with transfer\n    function transferWithLock(\n        address _to,\n        Lock calldata _lock\n    ) validLock(_lock) external {\n        super._transfer(msg.sender, _to, _lock.totalAmount);\n        Lock storage lock = locks[_to];\n        require(lock.schedules.length + _lock.schedules.length < maxSchedules, \"Maximum locks on address\");\n        lock.totalAmount += _lock.totalAmount;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lock.schedules.push(\n                Schedule(\n                    _lock.schedules[i].amount, \n                _lock.schedules[i].expirationBlock\n            ));\n        }\n        totalLocked += _lock.totalAmount;\n        emit LockedTransfer(_lock, msg.sender, _to);\n    }\n\n    /*\n     * Internal functions\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        _updateLock(_from, _to, _amount);\n        super._transfer(_from, _to, _amount);\n    }\n\n    /// @dev internal function to update relevant lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param _amount transaction amount\n    function _updateLock(address _from, address _to, uint256 _amount) internal {\n        if (updateRecipientLock(_from, _to, _amount)) { return; }\n        updateSenderLock(_from, _to, _amount);\n    }\n\n    /// @dev internal function to update the sender's lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateSenderLock(address _from, address _to, uint256 sendAmount) internal {\n        Lock storage senderLock = locks[_from];\n\n        // no lock on sender\n        if (senderLock.totalAmount == 0) {\n            return;\n        }\n        // staking tokens\n        if (isStakeableContract[_to]) {\n            senderLock.amountStaked += sendAmount;\n            return;\n        }\n\n        uint256 amountToUnlock;\n        uint256 deleteOffset;\n        uint256 totalSenderSchedules = senderLock.schedules.length;\n        for (uint256 i = 0; i < totalSenderSchedules + deleteOffset; i++) {\n            uint256 index = i - deleteOffset;\n            if (block.timestamp >= senderLock.schedules[index].expirationBlock) {\n                amountToUnlock += senderLock.schedules[index].amount;\n                senderLock.schedules[index] = senderLock.schedules[totalSenderSchedules-1];\n                senderLock.schedules.pop();\n                deleteOffset++;\n                totalSenderSchedules--;\n                emit LockScheduleExpired(_from, locks[_from]);\n            }\n        }\n        uint256 availableAmount = \n            amountToUnlock + super.balanceOf(_from) + senderLock.amountStaked - senderLock.totalAmount;\n        senderLock.totalAmount -= amountToUnlock;\n        totalLocked = totalLocked < amountToUnlock ? 0 : totalLocked -= amountToUnlock;\n        require(availableAmount >= sendAmount, \"Insufficient unlocked funds\");\n        if (senderLock.totalAmount == 0) { \n            emit LockExpired( _from, locks[_from]);\n            delete locks[_from];\n        }\n    }\n\n    /// @dev internal function to update the recipient's lock if transaction is from stakeable contract\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateRecipientLock(address _from, address _to, uint256 sendAmount) internal returns (bool) {\n        if (!isStakeableContract[_from]) {\n            return false;\n        }\n\n        Lock storage recipientLock = locks[_to];\n        // lock does not exist\n        if (recipientLock.totalAmount == 0) {\n            return false;\n        }\n        recipientLock.amountStaked = \n        recipientLock.amountStaked >= sendAmount ? \n        recipientLock.amountStaked - sendAmount: 0;\n        return true;\n    }\n\n    // ADMIN\n\n    /// @dev external function to update minimum lock time\n    /// @param _newMin new minimum locking time\n    function setMinLockTime(uint256 _newMin) external onlyOwner() {\n        minLockTime = _newMin;\n    }\n\n    /// @dev external function to get minimum lock time\n    function getMinLockTime() external view returns (uint256) {\n        return minLockTime;\n    }\n\n    /// @dev external function to update maximum lock time\n    /// @param _newMax new maximum locking time\n    function setMaxLockTime(uint256 _newMax) external onlyOwner() {\n        maxLockTime = _newMax;\n    }\n\n    /// @dev external function to get maximum lock time\n    function getMaxLockTime() external view returns (uint256) {\n        return maxLockTime;\n    }\n\n    /// @dev external function to update maximum number of schedules per lock\n    /// @param _newMax new maximum number of shedules per lock\n    function setMaxSchedules(uint256 _newMax) external onlyOwner() {\n        maxSchedules = _newMax;\n    }\n\n    /// @dev external function to get maximum number of schedules per lock\n    function getMaxSchedules() external view returns (uint256) {\n        return maxSchedules;\n    }\n\n    /// @dev external function to add a stakeable contract\n    /// @param stakingContract address of the staking contract to be added\n    function addStakeableContract(address stakingContract) external onlyOwner() {\n        require(stakingContract != address(0), \"Invalid staking address\");\n        isStakeableContract[stakingContract] = true;\n    }\n\n    /// @dev external function to remove a stakeable contract\n    /// @param stakingContract address of the staking contract to be removed\n    function removeStakeableContract(address stakingContract) external onlyOwner() {\n        require(isStakeableContract[stakingContract], \"Invalid staking address\");\n        isStakeableContract[stakingContract] = false;\n    }\n\n    // WEB3 interface\n    function getLockSchedules(address owner) public view returns(Schedule[] memory){\n        Lock memory lock = locks[owner];\n        return lock.schedules;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return super.balanceOf(account) - lockedBalanceOf(account);\n    }\n\n    function lockedBalanceOf(address account) public view returns (uint256) {\n        Lock memory senderLock = locks[account];\n        uint256 lockedBalance;\n        for (uint256 i = 0; i < senderLock.schedules.length; i++) {\n            if (block.timestamp < senderLock.schedules[i].expirationBlock) {\n                lockedBalance += senderLock.schedules[i].amount;\n            }\n        }\n        return lockedBalance;\n    }\n\n    function refundLockedTokensToOwner() external {\n        uint256 lockedBalance = lockedBalanceOf(msg.sender);\n        totalLocked = totalLocked < lockedBalance ? 0 : totalLocked -= lockedBalance;\n        super._transfer(msg.sender, owner(), lockedBalanceOf(msg.sender));\n        delete locks[msg.sender];\n        emit LockReturned(msg.sender, totalLocked);\n    }\n}"
    },
    "contracts/SOURCE/SourceToken.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20SOUL.sol\";\n\ncontract SourceToken is ERC20SOUL {\n    function initialize (\n        uint256 initialSupply,\n        address[] calldata stakableContracts) external virtual initializer {\n        ERC20SOUL.initializeERC20SOUL(\"Source\", \"SOURCE\", initialSupply, stakableContracts);\n    }\n}"
    },
    "contracts/SOURCE/ERC20SOUL.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title ERC20SOUL - An ERC20 extension that enables the transfer of\n/// tokens alongside locking periods that can be applied to subsets of\n/// the total transfer amount. This implementation also allows the owner\n/// to specify staking contract addresses that locked addresses can \n/// interact with.\n/// @author Bridger Zoske - bridger@resourcenetwork.co\ncontract ERC20SOUL is ERC20Upgradeable, OwnableUpgradeable {\n    /*\n     *  Events\n     */\n    event LockedTransfer(\n        Lock lock,\n        address sender,\n        address recipient\n    );\n\n    event LockExpired(\n        address owner,\n        Lock lock\n    );\n\n    event LockScheduleExpired(\n        address owner,\n        Lock lock\n    );\n\n    /*\n     *  Storage\n     */\n    mapping (address => bool) public isStakeableContract;\n    mapping(address => Lock) public locks;\n    uint256 public minLockTime;\n    uint256 public maxLockTime;\n    uint256 public maxSchedules;\n\n    struct Lock {\n        uint256 totalAmount;\n        uint256 amountStaked;\n        Schedule[] schedules;\n    }\n\n    struct Schedule {\n        uint256 amount;\n        uint256 expirationBlock;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier validLock(Lock calldata _lock) {\n        require(_lock.totalAmount > 0, \"Invalid Lock amount\");\n        uint256 totalLocked;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            totalLocked += _lock.schedules[i].amount;\n            require(_lock.schedules[i].expirationBlock > \n                block.timestamp + minLockTime, \"Lock schedule does not meet minimum\");\n            require(_lock.schedules[i].expirationBlock < \n                block.timestamp + maxLockTime, \"Lock schedule does not meet maximum\");\n        }\n        require(totalLocked == _lock.totalAmount, \"Invalid Lock\");\n        _;\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract initialzer sets ERC20 token data and stakeable contracts\n    /// @param name Name of ERC20 token\n    /// @param symbol Symbol of ERC20 token\n    /// @param initialSupply Initial supply of ERC20 token\n    /// @param stakeableContracts List of valid staking contracts \n    function initializeERC20SOUL(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address[] calldata stakeableContracts\n    ) public virtual initializer {\n        __ERC20_init(name, symbol);\n        __Ownable_init();\n        _mint(msg.sender, initialSupply);\n        minLockTime = 1 days;\n        maxLockTime = 1825 days; \n        maxSchedules = 260;\n        for (uint256 i = 0; i < stakeableContracts.length; i++) {\n            require(stakeableContracts[i] != address(0), \"invalid stakeable contract address\");\n            isStakeableContract[stakeableContracts[i]] = true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        _updateLock(_from, _to, _amount);\n        super._transfer(_from, _to, _amount);\n    }\n\n    /// @dev Creates a valid recipient lock after transfering tokens\n    /// @param _to address to send tokens to\n    /// @param _lock valid lock data associated with transfer\n    function transferWithLock(\n        address _to,\n        Lock calldata _lock\n    ) validLock(_lock) external onlyOwner() {\n        super._transfer(msg.sender, _to, _lock.totalAmount);\n        Lock storage lock = locks[_to];\n        require(lock.schedules.length + _lock.schedules.length < maxSchedules, \"Maximum locks on address\");\n        lock.totalAmount += _lock.totalAmount;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lock.schedules.push(\n                Schedule(\n                    _lock.schedules[i].amount, \n                _lock.schedules[i].expirationBlock\n            ));\n        }\n        emit LockedTransfer(_lock, msg.sender, _to);\n    }\n\n    /// @dev internal function to update relevant lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param _amount transaction amount\n    function _updateLock(address _from, address _to, uint256 _amount) internal {\n        if (updateRecipientLock(_from, _to, _amount)) { return; }\n        updateSenderLock(_from, _to, _amount);\n    }\n\n    /// @dev internal function to update the sender's lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateSenderLock(address _from, address _to, uint256 sendAmount) internal {\n        Lock storage senderLock = locks[_from];\n\n        // no lock on sender\n        if (senderLock.totalAmount == 0) {\n            return;\n        }\n        // staking tokens\n        if (isStakeableContract[_to]) {\n            senderLock.amountStaked += sendAmount;\n            return;\n        }\n\n        uint256 amountToUnlock;\n        uint256 deleteOffset;\n        uint256 totalSenderSchedules = senderLock.schedules.length;\n        for (uint256 i = 0; i < totalSenderSchedules + deleteOffset; i++) {\n            uint256 index = i - deleteOffset;\n            if (block.timestamp >= senderLock.schedules[index].expirationBlock) {\n                amountToUnlock += senderLock.schedules[index].amount;\n                senderLock.schedules[index] = senderLock.schedules[totalSenderSchedules-1];\n                senderLock.schedules.pop();\n                deleteOffset++;\n                totalSenderSchedules--;\n                emit LockScheduleExpired(_from, locks[_from]);\n            }\n            \n\n        }\n        uint256 availableAmount = \n            amountToUnlock + balanceOf(_from) + senderLock.amountStaked - senderLock.totalAmount;\n        senderLock.totalAmount -= amountToUnlock;\n        require(availableAmount >= sendAmount, \"Insufficient unlocked funds\");\n        if (senderLock.totalAmount == 0) { \n            emit LockExpired( _from, locks[_from]);\n            delete locks[_from];\n        }\n    }\n\n    /// @dev internal function to update the recipient's lock if transaction is from stakeable contract\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateRecipientLock(address _from, address _to, uint256 sendAmount) internal returns (bool) {\n        if (!isStakeableContract[_from]) {\n            return false;\n        }\n\n        Lock storage recipientLock = locks[_to];\n        // lock does not exist\n        if (recipientLock.totalAmount == 0) {\n            return false;\n        }\n        recipientLock.amountStaked = \n        recipientLock.amountStaked >= sendAmount ? \n        recipientLock.amountStaked - sendAmount: 0;\n        return true;\n    }\n\n    /// @dev external function to update minimum lock time\n    /// @param _newMin new minimum locking time\n    function setMinLockTime(uint256 _newMin) external onlyOwner() {\n        minLockTime = _newMin;\n    }\n\n    /// @dev external function to update maximum lock time\n    /// @param _newMax new maximum locking time\n    function setMaxLockTime(uint256 _newMax) external onlyOwner() {\n        maxLockTime = _newMax;\n    }\n    /// @dev external function to update maximum number of schedules per lock\n    /// @param _newMax new maximum number of shedules per lock\n    function setMaxSchedules(uint256 _newMax) external onlyOwner() {\n        maxSchedules = _newMax;\n    }\n\n    /// @dev external function to add a stakeable contract\n    /// @param stakingContract address of the staking contract to be added\n    function addStakeableContract(address stakingContract) external onlyOwner() {\n        require(stakingContract != address(0), \"Invalid staking address\");\n        isStakeableContract[stakingContract] = true;\n    }\n\n    /// @dev external function to remove a stakeable contract\n    /// @param stakingContract address of the staking contract to be removed\n    function removeStakeableContract(address stakingContract) external onlyOwner() {\n        require(isStakeableContract[stakingContract], \"Invalid staking address\");\n        isStakeableContract[stakingContract] = false;\n    }\n}"
    },
    "contracts/Credit/CreditManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./interface/IPriceOracle.sol\";\nimport \"./interface/ICreditManager.sol\";\nimport \"./interface/ICreditRoles.sol\";\nimport \"./interface/ICreditPool.sol\";\nimport \"../Network/interface/ICIP36.sol\";\n\ncontract CreditManager is OwnableUpgradeable, PausableUpgradeable, ICreditManager {\n    /* ========== CONSTANTS ========== */\n\n    uint32 private constant MAX_PPM = 1000000;\n    uint32 private constant MIN_PPT = 1000;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public collateralToken;\n    ICreditRoles public creditRoles;\n    IPriceOracle public oracle;\n    uint256 public totalStakedCollateral;\n    uint256 public minLTV;\n    uint256 public creditLineExpiration;\n    // network => member => creditline\n    mapping(address => mapping(address => CreditLine)) public creditLines;\n    // poolAddress => pool\n    mapping(address => bool) public pools;\n\n    /* ========== INITIALIZER ========== */\n\n    function initialize(\n        address collateralTokenAddress,\n        address _creditRoles,\n        address _oracle\n    ) external virtual initializer {\n        collateralToken = IERC20(collateralTokenAddress);\n        creditRoles = ICreditRoles(_creditRoles);\n        oracle = IPriceOracle(_oracle);\n        _setMinLTV(200000);\n        _setCreditLineExpirationDays(180 days);\n        __Ownable_init();\n        __Pausable_init();\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    function createCreditLine(\n        address _networkMember,\n        address _pool,\n        uint256 _creditLimit,\n        address _network\n    )\n        external\n        override\n        onlyOperator\n        onlyRegisteredNetwork(_network)\n        onlyRegisteredPool(_pool)\n        onlyNewCreditLine(_network, _networkMember)\n    {\n        creditLines[_network][_networkMember] = CreditLine(_pool, block.timestamp, _creditLimit);\n        ICreditPool(_pool).increaseTotalCredit(_creditLimit);\n        totalStakedCollateral += _creditLimit;\n        ICIP36(_network).setCreditLimit(_networkMember, _creditLimit);\n        emit CreditLineCreated(_network, _networkMember, _pool, _creditLimit, block.timestamp);\n    }\n\n    function registerCreditPool(address _pool) external onlyOperator {\n        address underwriter = ICreditPool(_pool).getUnderwriter();\n        require(\n            creditRoles.isUnderwriter(underwriter),\n            \"CreditManager: pool underwriter is invalid\"\n        );\n        pools[_pool] = true;\n        emit CreditPoolAdded(_pool, underwriter);\n    }\n\n    function extendCreditLine(\n        address _network,\n        address _networkMember,\n        uint256 _creditLimit\n    ) external override onlyOperator creditLineExists(_network, _networkMember) {\n        uint256 curCreditLimit = ICIP36(_network).creditLimitOf(_networkMember);\n        require(curCreditLimit < _creditLimit, \"CreditManager: Invalid credit limit\");\n        CreditLine storage creditLine = creditLines[_network][_networkMember];\n        ICreditPool(creditLine.creditPool).increaseTotalCredit(_creditLimit - curCreditLimit);\n        totalStakedCollateral += _creditLimit - curCreditLimit;\n        creditLine.creditLimit = _creditLimit;\n        ICIP36(_network).setCreditLimit(_networkMember, _creditLimit);\n        emit CreditLineLimitUpdated(_network, _networkMember, _creditLimit);\n    }\n\n    function swapCreditLinePool(\n        address _network,\n        address _networkMember,\n        address _pool\n    )\n        external\n        override\n        onlyOperator\n        onlyRegisteredPool(_pool)\n        creditLineExists(_network, _networkMember)\n    {\n        CreditLine storage creditLine = creditLines[_network][_networkMember];\n        ICreditPool(creditLine.creditPool).reduceTotalCredit(creditLine.creditLimit);\n        ICreditPool(_pool).increaseTotalCredit(creditLine.creditLimit);\n        creditLine.creditPool = _pool;\n        emit CreditLinePoolUpdated(_network, _networkMember, _pool);\n    }\n\n    function closeCreditLine(address _network, address _networkMember)\n        external\n        onlyExpiredCreditLine(_network, _networkMember)\n        onlyZeroBalance(_network, _networkMember)\n    {\n        CreditLine memory creditLine = creditLines[_network][_networkMember];\n        address underwriter = ICreditPool(creditLine.creditPool).getUnderwriter();\n        require(\n            underwriter == msg.sender || msg.sender == _networkMember,\n            \"CreditManager: caller is not underwriter or network member\"\n        );\n        ICreditPool(creditLine.creditPool).reduceTotalCredit(\n            ICIP36(_network).creditLimitOf(_networkMember)\n        );\n        ICIP36(_network).setCreditLimit(_networkMember, 0);\n        ICreditPool(creditLine.creditPool).reduceTotalCredit(creditLine.creditLimit);\n        totalStakedCollateral -= creditLine.creditLimit;\n        delete creditLines[_network][_networkMember];\n        emit CreditLineRemoved(_network, _networkMember);\n    }\n\n    function renewCreditLine(address _network, address _networkMember)\n        external\n        override\n        onlyOperator\n    {\n        creditLines[_network][_networkMember].issueDate = block.timestamp;\n        emit CreditLineRenewed(_network, _networkMember, block.timestamp);\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isPoolValidLTV(address _network, address _pool) public view override returns (bool) {\n        uint256 LTV = calculatePoolLTV(_network, _pool);\n        return LTV > minLTV;\n    }\n\n    function calculatePoolLTV(address _network, address _pool) public view returns (uint256) {\n        uint256 collateral = ICreditPool(_pool).totalSupply();\n        if (collateral == 0) return 0;\n\n        uint256 creditInCollateralUnits = convertNetworkToCollateral(\n            _network,\n            ICreditPool(_pool).getTotalCredit()\n        );\n        return (creditInCollateralUnits / collateral) * MAX_PPM;\n    }\n\n    function calculatePercentInCollateral(\n        address _networkToken,\n        uint256 _percent,\n        uint256 _amount\n    ) public view override returns (uint256) {\n        uint256 collateralAmount = convertNetworkToCollateral(_networkToken, _amount);\n        return ((_percent * collateralAmount) / MAX_PPM);\n    }\n\n    function isCreditLineExpired(address _network, address _networkMember)\n        public\n        view\n        override\n        returns (bool)\n    {\n        CreditLine memory creditLine = creditLines[_network][_networkMember];\n        return creditLine.issueDate + creditLineExpiration < block.timestamp;\n    }\n\n    function getCollateralToken() external view override returns (address) {\n        return address(collateralToken);\n    }\n\n    function getMinLTV() external view override returns (uint256) {\n        return minLTV;\n    }\n\n    function getCreditLine(address _network, address _networkMember)\n        public\n        view\n        override\n        returns (CreditLine memory)\n    {\n        return creditLines[_network][_networkMember];\n    }\n\n    function getCreditLineUnderwriter(address _network, address _networkMember)\n        public\n        view\n        override\n        returns (address)\n    {\n        address pool = creditLines[_network][_networkMember].creditPool;\n        if (pool == address(0)) return pool;\n        return ICreditPool(pool).getUnderwriter();\n    }\n\n    function getNeededCollateral(address _network, address _networkMember)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address pool = creditLines[_network][_networkMember].creditPool;\n        if (isPoolValidLTV(_network, pool)) return 0;\n        uint256 totalCredit = ICreditPool(pool).getTotalCredit();\n        uint256 creditInCollateral = convertNetworkToCollateral(_network, totalCredit);\n        uint256 minimumCollateral = (creditInCollateral * minLTV) / MAX_PPM;\n        return minimumCollateral - ICreditPool(pool).totalSupply();\n    }\n\n    function convertNetworkToCollateral(address _network, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 collateralDecimals = IERC20Metadata(address(collateralToken)).decimals();\n        uint256 networkDecimals = IERC20Metadata(_network).decimals();\n        if (networkDecimals < collateralDecimals) {\n            uint256 delta = collateralDecimals - networkDecimals;\n            return (_amount * 10**delta * oracle.getPriceInPPT()) / MIN_PPT;\n        } else {\n            uint256 delta = networkDecimals - collateralDecimals;\n            return ((_amount / 10**delta) * oracle.getPriceInPPT()) / MIN_PPT;\n        }\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    function _setMinLTV(uint32 _percentage) private {\n        require(_percentage <= MAX_PPM, \">percentage\");\n        minLTV = _percentage;\n    }\n\n    function _setCreditLineExpirationDays(uint32 _days) private {\n        require(_days >= 1 days, \"expiration day must be greater than 0\");\n        creditLineExpiration = _days;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyOperator() {\n        require(\n            creditRoles.isCreditOperator(msg.sender),\n            \"CreditManager: Caller must be an operator\"\n        );\n        _;\n    }\n\n    modifier onlyNewCreditLine(address _network, address _networkMember) {\n        require(\n            creditLines[_network][_networkMember].issueDate == 0,\n            \"CreditManager: Credit line already exists for network member\"\n        );\n        _;\n    }\n\n    modifier creditLineExists(address _network, address _networkMember) {\n        require(\n            creditLines[_network][_networkMember].issueDate > 0,\n            \"CreditManager: Credit line does not exist for network member\"\n        );\n        _;\n    }\n\n    modifier onlyExpiredCreditLine(address _network, address _networkMember) {\n        require(\n            isCreditLineExpired(_network, _networkMember),\n            \"CreditManager: Can't close active credit line\"\n        );\n        _;\n    }\n\n    modifier onlyZeroBalance(address _network, address _networkMember) {\n        require(\n            ICIP36(_network).creditBalanceOf(_networkMember) == 0,\n            \"CreditManager: Line of Credit has outstanding balance\"\n        );\n        _;\n    }\n\n    modifier onlyUnderwriter(address _underwriter) {\n        require(\n            creditRoles.isUnderwriter(_underwriter),\n            \"CreditManager: Underwriter address is not authorized\"\n        );\n        _;\n    }\n\n    modifier onlyRegisteredNetwork(address _network) {\n        require(\n            creditRoles.isNetwork(_network),\n            \"CreditManager: Network token address is not registered\"\n        );\n        _;\n    }\n\n    modifier onlyRegisteredPool(address _pool) {\n        require(pools[_pool], \"CreditManager: Pool is not registered\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/Credit/interface/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceOracle {\n    function getPriceInPPT() external view returns (uint256);\n}\n"
    },
    "contracts/Credit/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interface/IPriceOracle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PriceOracle is IPriceOracle, Ownable {\n    uint256 public price;\n    address public oracleManager;\n\n    constructor(uint256 _price, address _oracleManager) {\n        price = _price;\n        oracleManager = _oracleManager;\n    }\n\n    function setPrice(uint256 _price) external onlyOracleManager {\n        price = _price;\n    }\n\n    function getPriceInPPT() external view override returns (uint256) {\n        return price;\n    }\n\n    function setOracleManager(address _oracleManager) external onlyOwner {\n        oracleManager = _oracleManager;\n    }\n\n    modifier onlyOracleManager() {\n        require(msg.sender == oracleManager, \"PriceOracle: Caller must be manager.\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/SOURCE/TokenVesting.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title TokenVesting - This contract enables the storage of\n/// tokens alongside a vesting schdule that release a subset\n/// of the total amount stored on a time schduel. This implementation \n/// also allows the owner to revoke a given schedule's tokens\n/// in the case that a beneficiary does not meet the vesting \n/// requirement. \n/// Original repository can be found at:\n/// https://github.com/abdelhamidbakhta/token-vesting-contracts\n/// @author Abdelhamid Bakhta - abdelhamid.bakhta@gmail.com\ncontract TokenVesting is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    struct VestingSchedule {\n        // whether or not the vesting has been revoked\n        bool revocable;\n        // beneficiary of tokens after they are released\n        bool revoked;\n        // whether or not the vesting is revocable\n        address beneficiary;\n        // cliff period in seconds\n        uint256 cliff;\n        // start time of the vesting period\n        uint256 start;\n        // duration of the vesting period in seconds\n        uint256 duration;\n        // duration of a slice period for the vesting in seconds\n        uint256 slicePeriodSeconds;\n        // total amount of tokens to be released at the end of the vesting\n        uint256 amountTotal;\n        // amount of tokens released\n        uint256 released;\n    }\n\n    // address of the ERC20 token\n    IERC20 immutable private _token;\n\n    bytes32[] private vestingSchedulesIds;\n    mapping(bytes32 => VestingSchedule) private vestingSchedules;\n    uint256 private vestingSchedulesTotalAmount;\n    mapping(address => uint256) private holdersVestingCount;\n\n    event Released(uint256 amount);\n    event Revoked();\n\n\n    /**\n    * @dev Reverts if the address is null.\n    */\n    modifier notNull(address _address) {\n        require(_address != address(0), \"Invalid address\");\n        _;\n    }\n\n    /**\n    * @dev Reverts if the vesting schedule does not exist or has been revoked.\n    */\n    modifier onlyIfVestingScheduleNotRevoked(bytes32 vestingScheduleId) {\n        require(vestingSchedules[vestingScheduleId].beneficiary != address(0));\n        require(vestingSchedules[vestingScheduleId].revoked == false);\n        _;\n    }\n\n    /**\n     * @dev Creates a vesting contract.\n     * @param token_ address of the ERC20 token contract\n     */\n    constructor(address token_) {\n        require(token_ != address(0x0));\n        _token = IERC20(token_);\n    }\n\n    /**\n    * @dev Returns the number of vesting schedules associated to a beneficiary.\n    * @return the number of vesting schedules\n    */\n    function getVestingSchedulesCountByBeneficiary(address _beneficiary)\n    external\n    view\n    returns(uint256){\n        return holdersVestingCount[_beneficiary];\n    }\n\n    /**\n    * @dev Returns the vesting schedule id at the given index.\n    * @return the vesting id\n    */\n    function getVestingIdAtIndex(uint256 index)\n    external\n    view\n    returns(bytes32){\n        require(index < getVestingSchedulesCount(), \"TokenVesting: index out of bounds\");\n        return vestingSchedulesIds[index];\n    }\n\n    /**\n    * @notice Returns the vesting schedule information for a given holder and index.\n    * @return the vesting schedule structure information\n    */\n    function getVestingScheduleByAddressAndIndex(address holder, uint256 index)\n    external\n    view\n    returns(VestingSchedule memory){\n        return getVestingSchedule(computeVestingScheduleIdForAddressAndIndex(holder, index));\n    }\n\n\n    /**\n    * @notice Returns the total amount of vesting schedules.\n    * @return the total amount of vesting schedules\n    */\n    function getVestingSchedulesTotalAmount()\n    external\n    view\n    returns(uint256){\n        return vestingSchedulesTotalAmount;\n    }\n\n    /**\n    * @dev Returns the address of the ERC20 token managed by the vesting contract.\n    */\n    function getToken()\n    external\n    view\n    returns(address){\n        return address(_token);\n    }\n\n    /**\n    * @notice Creates a new vesting schedule for a beneficiary.\n    * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n    * @param _start start time of the vesting period\n    * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\n    * @param _duration duration in seconds of the period in which the tokens will vest\n    * @param _slicePeriodSeconds duration of a slice period for the vesting in seconds\n    * @param _revocable whether the vesting is revocable or not\n    * @param _amount total amount of tokens to be released at the end of the vesting\n    */\n    function createVestingSchedule(\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _slicePeriodSeconds,\n        bool _revocable,\n        uint256 _amount\n    )\n        public\n        notNull(_beneficiary)\n        onlyOwner{\n        require(\n            getWithdrawableAmount() >= _amount,\n            \"TokenVesting: cannot create vesting schedule because not sufficient tokens\"\n        );\n        require(_duration > 0, \"TokenVesting: duration must be > 0\");\n        require(_amount > 0, \"TokenVesting: amount must be > 0\");\n        require(_slicePeriodSeconds >= 1, \"TokenVesting: slicePeriodSeconds must be >= 1\");\n        bytes32 vestingScheduleId = computeNextVestingScheduleIdForHolder(_beneficiary);\n        uint256 cliff = _start + _cliff;\n        vestingSchedules[vestingScheduleId] = VestingSchedule(\n            _revocable,\n            false,\n            _beneficiary,\n            cliff,\n            _start,\n            _duration,\n            _slicePeriodSeconds,\n            _amount,\n            0\n        );\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount + _amount;\n        vestingSchedulesIds.push(vestingScheduleId);\n        uint256 currentVestingCount = holdersVestingCount[_beneficiary];\n        holdersVestingCount[_beneficiary] = currentVestingCount + 1;\n    }\n\n    /**\n    * @notice Revokes the vesting schedule for given identifier.\n    * @param vestingScheduleId the vesting schedule identifier\n    */\n    function revoke(bytes32 vestingScheduleId)\n        public\n        onlyOwner\n        onlyIfVestingScheduleNotRevoked(vestingScheduleId){\n        VestingSchedule storage vestingSchedule = vestingSchedules[vestingScheduleId];\n        require(vestingSchedule.revocable == true, \"TokenVesting: vesting is not revocable\");\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\n        if(vestedAmount > 0){\n            release(vestingScheduleId, vestedAmount);\n        }\n        uint256 unreleased = vestingSchedule.amountTotal - vestingSchedule.released;\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - unreleased;\n        vestingSchedule.revoked = true;\n    }\n\n    /**\n    * @notice Withdraw the specified amount if possible.\n    * @param amount the amount to withdraw\n    */\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        onlyOwner{\n        require(getWithdrawableAmount() >= amount, \"TokenVesting: not enough withdrawable funds\");\n        _token.safeTransfer(owner(), amount);\n    }\n\n    /**\n    * @notice Release vested amount of tokens.\n    * @param vestingScheduleId the vesting schedule identifier\n    * @param amount the amount to release\n    */\n    function release(\n        bytes32 vestingScheduleId,\n        uint256 amount\n    )\n        public\n        nonReentrant\n        onlyIfVestingScheduleNotRevoked(vestingScheduleId){\n        VestingSchedule storage vestingSchedule = vestingSchedules[vestingScheduleId];\n        bool isBeneficiary = msg.sender == vestingSchedule.beneficiary;\n        bool isOwner = msg.sender == owner();\n        require(\n            isBeneficiary || isOwner,\n            \"TokenVesting: only beneficiary and owner can release vested tokens\"\n        );\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\n        require(vestedAmount >= amount, \"TokenVesting: cannot release tokens, not enough vested tokens\");\n        vestingSchedule.released = vestingSchedule.released + amount;\n        address payable beneficiaryPayable = payable(vestingSchedule.beneficiary);\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - amount;\n        _token.safeTransfer(beneficiaryPayable, amount);\n    }\n\n    /**\n    * @dev Returns the number of vesting schedules managed by this contract.\n    * @return the number of vesting schedules\n    */\n    function getVestingSchedulesCount()\n        public\n        view\n        returns(uint256){\n        return vestingSchedulesIds.length;\n    }\n\n    /**\n    * @notice Computes the vested amount of tokens for the given vesting schedule identifier.\n    * @return the vested amount\n    */\n    function computeReleasableAmount(bytes32 vestingScheduleId)\n        public\n        onlyIfVestingScheduleNotRevoked(vestingScheduleId)\n        view\n        returns(uint256){\n        VestingSchedule storage vestingSchedule = vestingSchedules[vestingScheduleId];\n        return _computeReleasableAmount(vestingSchedule);\n    }\n\n    /**\n    * @notice Returns the vesting schedule information for a given identifier.\n    * @return the vesting schedule structure information\n    */\n    function getVestingSchedule(bytes32 vestingScheduleId)\n        public\n        view\n        returns(VestingSchedule memory){\n        return vestingSchedules[vestingScheduleId];\n    }\n\n    /**\n    * @dev Returns the amount of tokens that can be withdrawn by the owner.\n    * @return the amount of tokens\n    */\n    function getWithdrawableAmount()\n        public\n        view\n        returns(uint256){\n        return _token.balanceOf(address(this)) - vestingSchedulesTotalAmount;\n    }\n\n    /**\n    * @dev Computes the next vesting schedule identifier for a given holder address.\n    */\n    function computeNextVestingScheduleIdForHolder(address holder)\n        public\n        view\n        returns(bytes32){\n        return computeVestingScheduleIdForAddressAndIndex(holder, holdersVestingCount[holder]);\n    }\n\n    /**\n    * @dev Returns the last vesting schedule for a given holder address.\n    */\n    function getLastVestingScheduleForHolder(address holder)\n        public\n        view\n        returns(VestingSchedule memory){\n        return vestingSchedules[computeVestingScheduleIdForAddressAndIndex(holder, holdersVestingCount[holder] - 1)];\n    }\n\n    /**\n    * @dev Computes the vesting schedule identifier for an address and an index.\n    */\n    function computeVestingScheduleIdForAddressAndIndex(address holder, uint256 index)\n        public\n        pure\n        returns(bytes32){\n        return keccak256(abi.encodePacked(holder, index));\n    }\n\n    /**\n    * @dev Computes the releasable amount of tokens for a vesting schedule.\n    * @return the amount of releasable tokens\n    */\n    function _computeReleasableAmount(VestingSchedule memory vestingSchedule)\n    internal\n    view\n    returns(uint256){\n        uint256 currentTime = block.timestamp;\n        if ((currentTime < vestingSchedule.cliff) || vestingSchedule.revoked == true) {\n            return 0;\n        } else if (currentTime >= vestingSchedule.start + vestingSchedule.duration) {\n            return vestingSchedule.amountTotal - vestingSchedule.released;\n        } else {\n            uint256 timeFromStart = currentTime - vestingSchedule.start;\n            uint secondsPerSlice = vestingSchedule.slicePeriodSeconds;\n            uint256 vestedSlicePeriods = timeFromStart / secondsPerSlice;\n            uint256 vestedSeconds = vestedSlicePeriods * secondsPerSlice;\n            uint256 vestedAmount = vestingSchedule.amountTotal * vestedSeconds / vestingSchedule.duration;\n            vestedAmount = vestedAmount - vestingSchedule.released;\n            return vestedAmount;\n        }\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/SOURCE/SafeERC20SOUL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20SOUL.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n\n/**\n * @title SafeERC20SOUL\n * @dev Wrappers around ERC20SOUL operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20SOUL for IERC20SOUL;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20SOUL {\n    using Address for address;\n\n    // function safeTransfer(\n    //     IERC20SOUL token,\n    //     address to,\n    //     uint256 value\n    // ) internal {\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    // }\n\n    // function safeTransferWithLock(\n    //     IERC20SOUL token,\n    //     address _to,\n    //     IERC20SOUL.Lock calldata _lock\n    // ) internal {\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.transferWithLock.selector, _to, _lock));\n    // }\n\n    // function safeTransferFrom(\n    //     IERC20SOUL token,\n    //     address from,\n    //     address to,\n    //     uint256 value\n    // ) internal {\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    // }\n\n    // /**\n    //  * @dev Deprecated. This function has issues similar to the ones found in\n    //  * {IERC20SOUL-approve}, and its usage is discouraged.\n    //  *\n    //  * Whenever possible, use {safeIncreaseAllowance} and\n    //  * {safeDecreaseAllowance} instead.\n    //  */\n    // function safeApprove(\n    //     IERC20SOUL token,\n    //     address spender,\n    //     uint256 value\n    // ) internal {\n    //     // safeApprove should only be called when setting an initial allowance,\n    //     // or when resetting it to zero. To increase and decrease it, use\n    //     // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    //     require(\n    //         (value == 0) || (token.allowance(address(this), spender) == 0),\n    //         \"SafeERC20: approve from non-zero to non-zero allowance\"\n    //     );\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    // }\n\n    // function safeIncreaseAllowance(\n    //     IERC20SOUL token,\n    //     address spender,\n    //     uint256 value\n    // ) internal {\n    //     uint256 newAllowance = token.allowance(address(this), spender) + value;\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    // }\n\n    // function safeDecreaseAllowance(\n    //     IERC20SOUL token,\n    //     address spender,\n    //     uint256 value\n    // ) internal {\n    //     unchecked {\n    //         uint256 oldAllowance = token.allowance(address(this), spender);\n    //         require(oldAllowance >= value, \"SafeERC20SOUL: decreased allowance below zero\");\n    //         uint256 newAllowance = oldAllowance - value;\n    //         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    //     }\n    // }\n\n    // /**\n    //  * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n    //  * on the return value: the return value is optional (but if data is returned, it must not be false).\n    //  * @param token The token targeted by the call.\n    //  * @param data The call data (encoded using abi.encode or one of its variants).\n    //  */\n    // function _callOptionalReturn(IERC20SOUL token, bytes memory data) private {\n    //     // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    //     // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    //     // the target address contains contract code and also asserts for success in the low-level call.\n\n    //     bytes memory returndata = address(token).functionCall(data, \"SafeERC20SOUL: low-level call failed\");\n    //     if (returndata.length > 0) {\n    //         // Return data is optional\n    //         require(abi.decode(returndata, (bool)), \"SafeERC20SOUL: ERC20 operation did not succeed\");\n    //     }\n    // }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/Credit/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"Mock\", \"MOCK\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}