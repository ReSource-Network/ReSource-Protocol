{
  "language": "Solidity",
  "sources": {
    "contracts/CIP36/CIP36.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n\ncontract CIP36 is OwnableUpgradeable, ERC20BurnableUpgradeable {\n    using ExtraMath for *;\n\n    struct Member {\n        uint128 creditBalance;\n        uint128 creditLimit;\n    }\n\n    mapping(address => Member) private _members;\n\n    event CreditLimitUpdate(address member, uint256 limit);\n\n    function initialize(\n        string memory name_,\n        string memory symbol_\n    ) public virtual initializer {\n        __ERC20_init(name_, symbol_);\n        __Ownable_init();\n    }\n\n    modifier onlyAuthorized() virtual {\n        require(msg.sender == owner(), \"invalid caller address\");\n        _;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    function creditBalanceOf(address _member) public view returns (uint256) {\n        return _members[_member].creditBalance;\n    }\n\n    function creditLimitOf(address _member) external view returns (uint256) {\n        return _members[_member].creditLimit;\n    }\n\n    function creditLimitLeftOf(address _member) public view returns (uint256) {\n        Member memory _localMember = _members[_member];\n        if (_localMember.creditBalance >= _localMember.creditLimit) {\n            return 0;\n        }\n        return _localMember.creditLimit - _localMember.creditBalance;\n    }\n\n    function setCreditLimit(address _member, uint256 _limit) public virtual onlyAuthorized() {\n        _members[_member].creditLimit = _limit.toUInt128();\n        emit CreditLimitUpdate(_member, _limit);\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override {\n        _beforeTransfer(_from, _amount);\n        super._transfer(_from, _to, _amount);\n        _afterTransfer(_to, _amount);\n    }\n\n    function _beforeTransfer(address _from, uint256 _amount) private {\n        uint256 _balanceFrom = balanceOf(_from);\n        if (_balanceFrom >= _amount) {\n            return;\n        }\n\n        Member memory _memberFrom = _members[_from];\n        uint256 _missingBalance = _amount - _balanceFrom;\n        uint256 _creditLeft = creditLimitLeftOf(_from);\n        require(_creditLeft >= _missingBalance, \"Insufficient credit\");\n        _members[_from].creditBalance = (_memberFrom.creditBalance + _missingBalance).toUInt128();\n        _mint(_from, _missingBalance);\n    }\n\n    function _afterTransfer(address _to, uint256 _amount) private {\n        Member memory _memberTo = _members[_to];\n        uint256 _repay = Math.min(_memberTo.creditBalance, _amount);\n        if (_repay == 0) {\n            return;\n        }\n        _members[_to].creditBalance = (_memberTo.creditBalance - _repay).toUInt128();\n        _burn(_to, _repay);\n    }\n}\n\nlibrary ExtraMath {\n    function toUInt128(uint256 _a) internal pure returns (uint128) {\n        require(_a < 2**128 - 1, \"uin128 overflow\");\n        return uint128(_a);\n    }\n}"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/CIP36/UnderwriterManagerV2.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"./CIP36.sol\"; // Create interface for CIP36\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\ncontract UnderwriteManagerV2 is OwnableUpgradeable {\n    /*\n     *  Constants\n     */\n    uint256 public constant MWEI = 1000000000000;\n    \n    /*\n     *  Storage\n     */\n    bool public isActive;\n    IERC20 public collateralToken;\n    uint256 public totalCollateral;\n    mapping(address => CreditLine) public creditLines;\n    mapping(address => bool) public isUnderwriter;\n    mapping(address => bool) public isRegisteredNetwork;\n    uint256 public collateralBasisPoints;\n    uint256 public creditLineRenewalOffset;\n    uint256 public rewardPercent;\n    uint256 public creditLineExpiration;\n    uint256 public minimumCollateral;\n    uint256 public collateralPriceCents;\n\n\n    struct CreditLine {\n        address underwriter;\n        uint256 collateral;\n        address networkToken;\n        uint256 issueDate;\n        uint256 reward;\n    }\n    \n    struct CreditLineEvent {\n        address underwriter;\n        address counterparty;\n        CreditLine data;\n    }\n\n    struct CreditLineLimitEvent {\n        address underwriter;\n        address counterparty;\n        CreditLine data;\n        uint256 creditLimit;\n    }\n\n    /*\n     *  Events\n     */\n    event NewCreditLine(CreditLineLimitEvent creditLine);\n    event ExtendCreditLine(\n        CreditLineLimitEvent creditLine, \n        uint256 additionalCollateral\n    );\n    event CreditLineReward(CreditLineEvent creditLine);\n    event CreditLineRewardClaimed(\n        address underwriter,\n        address[] counterparties,\n        uint256[] rewards,\n        uint256 totalClaimed\n    );\n    event CreditLineWithdrawal(CreditLineLimitEvent creditLine);\n\n    function initialize(address collateralTokenAddress) external virtual initializer {\n        collateralToken = IERC20(collateralTokenAddress);\n        isActive = true;\n        collateralBasisPoints = 2000;\n        collateralPriceCents = 20;\n        rewardPercent = 2;\n        minimumCollateral = 600 ether;\n        creditLineRenewalOffset = 1 days;\n        creditLineExpiration = 180 days;\n        __Ownable_init();\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier notNull(address _address) {\n        require(_address != address(0), \"Invalid address\");\n        _;\n    }\n\n    modifier onlyNetwork(address _address) {\n        require(isRegisteredNetwork[_address] == true || _address == owner(), \"Invalid network address\");\n        _;\n    }\n\n    modifier validCreditRenewal(address underwriter, address counterparty) {\n        uint256 issueDate = creditLines[counterparty].issueDate;\n        require(block.timestamp - issueDate > creditLineExpiration, \"Credit line still active\");\n        _;\n    }\n\n    modifier newCreditLine(address counterparty) {\n        require(creditLines[counterparty].underwriter == address(0), \"Address already underwritten\");\n        _;\n    }\n\n    modifier ownedCreditLine(address underwriter, address counterparty) {\n        require(creditLines[counterparty].underwriter == underwriter, \"Credit line not owned\");\n        _;\n    }\n\n    modifier onlyUnderwriter(address underwriter) {\n        require(isUnderwriter[underwriter], \"Caller is not an underwriter\");\n        _;\n    }\n\n    modifier active() {\n        require(isActive == true, \"Manager is inactive\");\n        _;\n    }\n\n    /*\n     * Public functions\n     */\n    function underwriteCreditLine(\n        address networkToken,\n        uint256 collateralAmount,\n        address counterparty\n    ) \n    active \n    newCreditLine(counterparty) \n    notNull(networkToken) \n    notNull(counterparty) \n    onlyUnderwriter(msg.sender)\n    external {\n        CreditLine storage creditLine = creditLines[counterparty];\n        require(collateralAmount >= minimumCollateral, \"Insufficient collateral\");\n        require(isRegisteredNetwork[networkToken], \"Invalid network token\");\n        // use safe transfer from openzep\n        collateralToken.transferFrom(msg.sender, address(this), collateralAmount);\n        creditLine.collateral = collateralAmount;\n        creditLine.networkToken = networkToken;\n        creditLine.issueDate = block.timestamp;\n        creditLine.underwriter = msg.sender;\n        uint256 creditLimit = calculateCredit(collateralAmount);\n        emit NewCreditLine(CreditLineLimitEvent(\n            msg.sender, \n            counterparty, \n            CreditLine(\n                msg.sender,\n                creditLine.collateral, \n                creditLine.networkToken, \n                creditLine.issueDate,\n                0\n            ),\n            creditLimit\n        ));\n        CIP36(networkToken).setCreditLimit(counterparty, creditLimit); \n        totalCollateral += collateralAmount;\n    }\n\n    function extendCreditLine(address counterparty, uint256 collateralAmount) \n    active \n    notNull(counterparty) \n    ownedCreditLine(msg.sender, counterparty)\n    onlyUnderwriter(msg.sender)\n    external {\n        CreditLine storage creditLine = creditLines[counterparty];\n        // use safe transfer from openzep\n        collateralToken.transferFrom(msg.sender, address(this), collateralAmount);\n        creditLine.collateral += collateralAmount;\n        uint256 creditLimit = calculateCredit(creditLine.collateral);\n        CIP36(creditLine.networkToken).setCreditLimit(counterparty, creditLimit);\n        totalCollateral += collateralAmount;\n        emit ExtendCreditLine(CreditLineLimitEvent(\n            msg.sender, \n            counterparty, \n            CreditLine(\n                msg.sender,\n                creditLine.collateral, \n                creditLine.networkToken, \n                creditLine.issueDate,\n                0\n            ),\n            creditLimit\n        ), collateralAmount);\n    }\n\n    function withdrawCreditLine(address counterparty) external \n        ownedCreditLine(msg.sender, counterparty)\n        validCreditRenewal(msg.sender, counterparty) \n        notNull(counterparty) {\n\n        CreditLine memory creditLine = creditLines[counterparty];\n        uint256 collateral = creditLine.collateral;\n        require (collateral > 0, \"Can't withdraw from empty credit line\");\n        uint256 creditBalance = CIP36(creditLine.networkToken).creditBalanceOf(counterparty);\n        uint256 offsetBalance = creditBalance * MWEI;\n        uint256 total = creditLine.collateral + creditLine.reward - offsetBalance;\n        require( offsetBalance > 0, \"Can't withdraw from active credit line\");\n        CIP36(creditLine.networkToken).setCreditLimit(counterparty, 0);\n        collateralToken.transfer(msg.sender, total);\n        delete creditLines[counterparty];\n        totalCollateral -= collateral;\n        emit CreditLineWithdrawal(CreditLineLimitEvent(\n            msg.sender, \n            counterparty, \n            CreditLine(\n                msg.sender,\n                creditLine.collateral, \n                creditLine.networkToken, \n                creditLine.issueDate,\n                0\n            ),\n            0\n        ));\n    }\n\n    function renewCreditLine(address counterparty) external \n    ownedCreditLine(msg.sender, counterparty) \n    validCreditRenewal(msg.sender, counterparty) {\n        CreditLine storage creditLine = creditLines[counterparty];\n        creditLine.issueDate = block.timestamp;\n    }\n\n    function tryUpdateReward(address counterparty, uint256 txAmount) external \n    notNull(counterparty) \n    onlyNetwork(msg.sender) {\n        CreditLine storage creditLine = creditLines[counterparty];\n        if (creditLine.collateral == 0) {\n            return;\n        }\n        address underwriter = creditLines[counterparty].underwriter;\n        tryRenewCreditLine(counterparty);\n        uint256 reward = calculateReward(txAmount);\n        creditLine.reward += reward;\n        emit CreditLineReward(CreditLineEvent(\n            underwriter, \n            counterparty, \n            CreditLine(\n                msg.sender,\n                creditLine.collateral, \n                creditLine.networkToken, \n                creditLine.issueDate,\n                reward\n            )\n        ));\n    }\n\n    function claimRewards(address[] memory counterparties) onlyUnderwriter(msg.sender) external {\n        uint256 totalReward;\n        uint256[] memory rewards = new uint256[](counterparties.length);\n        for (uint256 i = 0; i < counterparties.length; i++) {\n            CreditLine storage creditLine = creditLines[counterparties[i]];\n            require(creditLine.underwriter == msg.sender, \"Credit line not owned\");\n            if (creditLine.reward == 0) {\n                continue;\n            }\n            rewards[i] = creditLine.reward;\n            totalReward += creditLine.reward;\n            creditLine.reward = 0;\n        }\n        require(totalReward > 0, \"No reward to claim\");\n        require(collateralToken.balanceOf(address(this)) - totalReward > totalCollateral, \"Insufficient funds in reward pool\");\n        // use safe transfer from openzep\n        collateralToken.transfer(msg.sender, totalReward);\n        emit CreditLineRewardClaimed(msg.sender, counterparties, rewards, totalReward);\n    }\n\n    function activate() external onlyOwner() {\n        isActive = true;\n    }\n\n    function deactivate() external onlyOwner() {\n        isActive = false;\n    }\n\n    function updateCollateralBP(uint256 _collateralBasisPoints) external onlyOwner() {\n        collateralBasisPoints = _collateralBasisPoints;\n    }\n    \n    function updateCreditLineRenewalOffset(uint256 _creditLineRenewalOffset) external onlyOwner() {\n        creditLineRenewalOffset = _creditLineRenewalOffset;\n    }\n\n    function updateRewardPercent(uint256 _rewardPercent) external onlyOwner() {\n        rewardPercent = _rewardPercent;\n    }\n\n    function updateCreditLineExpiration(uint256 _creditLineExpiration) external onlyOwner() {\n        creditLineExpiration = _creditLineExpiration;\n    }\n\n    function updateMinimumCollateral(uint256 _minimumCollateral) external onlyOwner() {\n        minimumCollateral = _minimumCollateral;\n    }\n\n    function updateCollateralPriceCents(uint256 _collateralPriceCents) external onlyOwner() {\n        collateralPriceCents = _collateralPriceCents;\n    }\n\n\n\n    function updateUnderwriters(address[] memory _underwriters, bool[] memory _isUnderwriter) external onlyOwner() {\n        require(_underwriters.length == _isUnderwriter.length, \"Invalid update value length\");\n        for (uint256 i = 0; i < _underwriters.length; i++) {\n            isUnderwriter[_underwriters[i]] = _isUnderwriter[i];\n        }\n    }\n\n    function addNetwork(address networkAddress) external onlyOwner() {\n        isRegisteredNetwork[networkAddress] = true;\n    }\n\n    function removeNetwork(address networkAddress) external onlyOwner() {\n        isRegisteredNetwork[networkAddress] = false;\n    }\n\n    // Returns calculation in mwei units\n    function calculateCredit(uint256 collateralAmount) public view returns (uint256) {\n        return ((collateralAmount * collateralPriceCents * 100) / (collateralBasisPoints * MWEI));\n    }\n    // Returns calculation in ether units\n    function calculateCollateral(uint256 creditAmount) public view returns (uint256) {\n        return ((creditAmount * collateralPriceCents * 100 * MWEI) / (collateralBasisPoints));\n    }\n\n    /*\n     * Private functions\n     */\n    function calculateReward(uint256 txAmount) private view returns (uint256) {\n        return (txAmount / 100) * rewardPercent * MWEI;\n    }\n\n    function tryRenewCreditLine(address counterparty) private {\n        if ((block.timestamp - creditLines[counterparty].issueDate) > creditLineExpiration + creditLineRenewalOffset) {\n            creditLines[counterparty].issueDate = block.timestamp;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/SOURCE/SafeERC20SOUL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20SOUL.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n\n/**\n * @title SafeERC20SOUL\n * @dev Wrappers around ERC20SOUL operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20SOUL for IERC20SOUL;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20SOUL {\n    using Address for address;\n\n    // function safeTransfer(\n    //     IERC20SOUL token,\n    //     address to,\n    //     uint256 value\n    // ) internal {\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    // }\n\n    // function safeTransferWithLock(\n    //     IERC20SOUL token,\n    //     address _to,\n    //     IERC20SOUL.Lock calldata _lock\n    // ) internal {\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.transferWithLock.selector, _to, _lock));\n    // }\n\n    // function safeTransferFrom(\n    //     IERC20SOUL token,\n    //     address from,\n    //     address to,\n    //     uint256 value\n    // ) internal {\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    // }\n\n    // /**\n    //  * @dev Deprecated. This function has issues similar to the ones found in\n    //  * {IERC20SOUL-approve}, and its usage is discouraged.\n    //  *\n    //  * Whenever possible, use {safeIncreaseAllowance} and\n    //  * {safeDecreaseAllowance} instead.\n    //  */\n    // function safeApprove(\n    //     IERC20SOUL token,\n    //     address spender,\n    //     uint256 value\n    // ) internal {\n    //     // safeApprove should only be called when setting an initial allowance,\n    //     // or when resetting it to zero. To increase and decrease it, use\n    //     // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    //     require(\n    //         (value == 0) || (token.allowance(address(this), spender) == 0),\n    //         \"SafeERC20: approve from non-zero to non-zero allowance\"\n    //     );\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    // }\n\n    // function safeIncreaseAllowance(\n    //     IERC20SOUL token,\n    //     address spender,\n    //     uint256 value\n    // ) internal {\n    //     uint256 newAllowance = token.allowance(address(this), spender) + value;\n    //     _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    // }\n\n    // function safeDecreaseAllowance(\n    //     IERC20SOUL token,\n    //     address spender,\n    //     uint256 value\n    // ) internal {\n    //     unchecked {\n    //         uint256 oldAllowance = token.allowance(address(this), spender);\n    //         require(oldAllowance >= value, \"SafeERC20SOUL: decreased allowance below zero\");\n    //         uint256 newAllowance = oldAllowance - value;\n    //         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    //     }\n    // }\n\n    // /**\n    //  * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n    //  * on the return value: the return value is optional (but if data is returned, it must not be false).\n    //  * @param token The token targeted by the call.\n    //  * @param data The call data (encoded using abi.encode or one of its variants).\n    //  */\n    // function _callOptionalReturn(IERC20SOUL token, bytes memory data) private {\n    //     // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    //     // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    //     // the target address contains contract code and also asserts for success in the low-level call.\n\n    //     bytes memory returndata = address(token).functionCall(data, \"SafeERC20SOUL: low-level call failed\");\n    //     if (returndata.length > 0) {\n    //         // Return data is optional\n    //         require(abi.decode(returndata, (bool)), \"SafeERC20SOUL: ERC20 operation did not succeed\");\n    //     }\n    // }\n}\n"
    },
    "contracts/SOURCE/IERC20SOUL.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title ERC20SOUL - An ERC20 extension that enables the transfer of\n/// tokens alongside locking periods that can be applied to subsets of\n/// the total transfer amount. This implementation also allows the owner\n/// to specify staking contract addresses that locked addresses can \n/// interact with.\n/// @author Bridger Zoske - <bridger@resourcenetwork.co>\ninterface IERC20SOUL {\n    /*\n     *  Events\n     */\n    event LockedTransfer(\n        Lock lock,\n        address sender,\n        address recipient\n    );\n\n    event LockExpired(\n        address owner,\n        Lock lock\n    );\n\n    event LockScheduleExpired(\n        address owner,\n        Lock lock\n    );\n\n    struct Lock {\n        uint256 totalAmount;\n        uint256 amountStaked;\n        Schedule[] schedules;\n    }\n\n    struct Schedule {\n        uint256 amount;\n        uint256 expirationBlock;\n    }\n\n    /// @dev external function to get minimum lock time\n    function getMinLockTime() external view returns (uint256);\n\n    /// @dev external function to get maximum lock time\n    function getMaxLockTime() external view returns (uint256);\n\n    /// @dev external function to get maximum number of schedules per lock\n    function getMaxSchedules() external view returns (uint256);\n\n    /// @dev Creates a valid recipient lock after transfering tokens\n    /// @param _to address to send tokens to\n    /// @param _lock valid lock data associated with transfer\n    function transferWithLock(address _to, Lock calldata _lock) external;\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "contracts/SOURCE/TokenClaim.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./IERC20SOUL.sol\";\n\n/// @title TokenClaim - This contract enables the storage of\n/// locked (specified by the ERC20SOUL standard) and unlocked\n/// tokens by a beneficiary address. This implementation also \n/// allows the owner to revoke a given claim in the case that\n/// a beneficiary does not or is unable to claim.\n/// @author Bridger Zoske - bridger@resourcenetwork.co\ncontract TokenClaim is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n\n    struct Claim {\n        uint256 unlockedAmount;\n        IERC20SOUL.Lock lock;\n        bool released;\n    }\n\n    // address of the ERC20 token\n    IERC20SOUL private _token;\n    mapping(address => Claim) public claims;\n    uint256 public totalClaimable;\n    \n    event Released(Claim claim);\n    event NewClaimAdded(Claim claim);\n    event ClaimUpdated(Claim claim);\n\n    /**\n    * @dev Reverts if the address is null.\n    */\n    modifier notNull(address _address) {\n        require(_address != address(0), \"Invalid address\");\n        _;\n    }\n\n    /**\n    * @dev Reverts if the claim does not exist or has been released.\n    */\n    modifier onlyIfClaimNotReleased(address beneficiary) {\n        require(getClaimTotal(beneficiary) != 0, \"TokenClaim: Claim does not exist\");\n        require(claims[beneficiary].released == false, \"TokenClaim: Claim has been released\");\n        _;\n    }\n\n    /**\n     * @dev Creates a claim contract.\n     * @param token_ address of the ERC20 token contract\n\n     */\n    function initialize(address token_) external virtual initializer {\n        require(token_ != address(0x0));\n        __Ownable_init();\n        _token = IERC20SOUL(token_);\n    }\n\n    /**\n    * @dev Returns the address of the ERC20 token managed by the claim contract.\n    */\n    function getToken()\n    external\n    view\n    returns(address){\n        return address(_token);\n    }\n\n    /**\n    * @notice Creates a new claim for a beneficiary.\n    * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n    * @param _unlockedAmount total unlocked amount in claim\n    * @param _lock lock structure for locked tokens in claim\n    */\n    function addClaim(\n        address _beneficiary,\n        uint256 _unlockedAmount,\n        IERC20SOUL.Lock calldata _lock\n    )\n        public\n        notNull(_beneficiary)\n        onlyOwner{\n        uint256 totalAmount = _unlockedAmount + _lock.totalAmount;\n        require(\n            getWithdrawableAmount() >= totalAmount,\n            \"TokenClaim: cannot create claim because not sufficient tokens\"\n        );\n        require(totalAmount > 0, \"TokenClaim: amount must be > 0\");\n\n        if (_lock.totalAmount > 0) {\n            validLock(_lock);\n        }\n\n        Claim storage _claim = claims[_beneficiary];\n\n        if (getClaimTotal(_beneficiary) == 0) {\n            _claim.lock = _lock;\n            _claim.unlockedAmount = _unlockedAmount;\n            emit NewClaimAdded(_claim);\n        } else {\n            _claim.lock.totalAmount += _lock.totalAmount;\n            for (uint256 i = 0; i < _lock.schedules.length; i++) {\n                _claim.lock.schedules.push(\n                    IERC20SOUL.Schedule(\n                        _lock.schedules[i].amount, \n                        _lock.schedules[i].expirationBlock\n                ));\n            }            \n            _claim.unlockedAmount += _unlockedAmount;\n            emit ClaimUpdated(_claim);\n        }\n        _claim.released = false;\n        totalClaimable += totalAmount;\n    }\n\n    function validLock(IERC20SOUL.Lock calldata _lock) internal view {\n        require(_lock.totalAmount > 0, \"Invalid Lock amount\");\n        uint256 lockTotal;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lockTotal += _lock.schedules[i].amount;\n            require(_lock.schedules[i].expirationBlock > \n                block.timestamp + _token.getMinLockTime(), \"Lock schedule does not meet minimum\");\n            require(_lock.schedules[i].expirationBlock < \n                block.timestamp + _token.getMaxLockTime(), \"Lock schedule does not meet maximum\");\n        }\n        require(lockTotal == _lock.totalAmount, \"Invalid Lock\");\n    }\n\n    /**\n    * @notice Revokes the claim for given beneficiary\n    * @param beneficiary address of claim owner\n    */\n    function revoke(address beneficiary)\n        public\n        onlyOwner\n        onlyIfClaimNotReleased(beneficiary){\n        totalClaimable -= getClaimTotal(beneficiary);\n        delete claims[beneficiary];\n    }\n\n    /**\n    * @notice Withdraw the specified amount if possible.\n    * @param amount the amount to withdraw\n    */\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        onlyOwner{\n        require(getWithdrawableAmount() >= amount, \"TokenClaim: not enough withdrawable funds\");\n        _token.transfer(owner(), amount);\n    }\n\n    /**\n    * @notice claim tokens\n    */\n    function claim()\n        public\n        nonReentrant\n        onlyIfClaimNotReleased(msg.sender) {\n        Claim storage _claim = claims[msg.sender];\n        if (_claim.unlockedAmount > 0) {\n            _token.transfer(msg.sender, _claim.unlockedAmount);\n        }\n        uint256 totalAmount = getClaimTotal(msg.sender);\n        if (_claim.lock.totalAmount > 0) {\n            _token.transferWithLock(msg.sender, _claim.lock);\n        }\n        delete claims[msg.sender];\n        _claim.released = true;\n        totalClaimable -= totalAmount;\n        emit Released(_claim);\n    }\n\n    /**\n    * @dev Returns the amount of tokens that can be withdrawn by the owner.\n    * @return the amount of tokens\n    */\n    function getWithdrawableAmount()\n        public\n        view\n        returns(uint256){\n        return _token.balanceOf(address(this)) - totalClaimable;\n    }\n\n     /**\n    * @dev Returns the amount of tokens that can be withdrawn by the owner.\n    * @return the amount of tokens\n    */\n    function getClaimTotal(address beneficiary)\n        public\n        view\n        returns(uint256){\n        Claim memory _claim = claims[beneficiary];\n        return _claim.unlockedAmount + _claim.lock.totalAmount;\n    }\n\n         /**\n    * @dev Returns the lock schedule of a given beneficiary.\n    * @return the lock schedule object of a claim\n    */\n    function getClaimLockSchedule(address beneficiary)\n        external\n        view\n        returns(IERC20SOUL.Schedule[] memory){\n        return claims[beneficiary].lock.schedules;\n    }\n}"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/SOURCE/SourceTokenV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20SOULV2.sol\";\n\ncontract SourceTokenV2 is ERC20SOULV2 {\n    function initialize (\n        uint256 initialSupply,\n        address[] calldata stakableContracts) external virtual initializer {\n        ERC20SOULV2.initializeERC20SOUL(\"Source\", \"SOURCE\", initialSupply, stakableContracts);\n    }\n}"
    },
    "contracts/SOURCE/ERC20SOULV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n\n/// @title ERC20SOUL - An ERC20 extension that enables the transfer of\n/// tokens alongside locking periods that can be applied to subsets of\n/// the total transfer amount. This implementation also allows the owner\n/// to specify staking contract addresses that locked addresses can \n/// interact with.\n/// @author Bridger Zoske - bridger@resourcenetwork.co\ncontract ERC20SOULV2 is ERC20Upgradeable, OwnableUpgradeable {\n    /*\n     *  Events\n     */\n    event LockedTransfer(\n        Lock lock,\n        address sender,\n        address recipient\n    );\n\n    event LockExpired(\n        address owner,\n        Lock lock\n    );\n\n    event LockScheduleExpired(\n        address owner,\n        Lock lock\n    );\n\n    event LockReturned(address owner, uint256 amount);\n\n    /*\n     *  Storage\n     */\n    mapping (address => bool) public isStakeableContract;\n    mapping(address => Lock) public locks;\n    uint256 public minLockTime;\n    uint256 public maxLockTime;\n    uint256 public maxSchedules;\n    uint256 public totalLocked;\n    bool private _upgradeV2;\n\n    struct Lock {\n        uint256 totalAmount;\n        uint256 amountStaked;\n        Schedule[] schedules;\n    }\n\n    struct Schedule {\n        uint256 amount;\n        uint256 expirationBlock;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier validLock(Lock calldata _lock) {\n        require(_lock.totalAmount > 0, \"Invalid Lock amount\");\n        uint256 lockTotal;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lockTotal += _lock.schedules[i].amount;\n            require(_lock.schedules[i].expirationBlock > \n                block.timestamp + minLockTime, \"Lock schedule does not meet minimum\");\n            require(_lock.schedules[i].expirationBlock < \n                block.timestamp + maxLockTime, \"Lock schedule does not meet maximum\");\n        }\n        require(lockTotal == _lock.totalAmount, \"Invalid Lock\");\n        _;\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract initialzer sets ERC20 token data and stakeable contracts\n    /// @param name Name of ERC20 token\n    /// @param symbol Symbol of ERC20 token\n    /// @param initialSupply Initial supply of ERC20 token\n    /// @param stakeableContracts List of valid staking contracts \n    function initializeERC20SOUL(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address[] calldata stakeableContracts\n    ) public virtual initializer {\n        __ERC20_init(name, symbol);\n        __Ownable_init();\n        _mint(msg.sender, initialSupply);\n        minLockTime = 1 days;\n        maxLockTime = 1825 days; \n        maxSchedules = 260;\n        for (uint256 i = 0; i < stakeableContracts.length; i++) {\n            require(stakeableContracts[i] != address(0), \"invalid stakeable contract address\");\n            isStakeableContract[stakeableContracts[i]] = true;\n        }\n    }\n\n    function upgradeV2() public {\n        require (!_upgradeV2, \"ERC20SOULV2: already upgraded to V2\");\n        _upgradeV2 = true;\n        totalLocked = 1500000 ether;\n    }\n\n    /// @dev Creates a valid recipient lock after transfering tokens\n    /// @param _to address to send tokens to\n    /// @param _lock valid lock data associated with transfer\n    function transferWithLock(\n        address _to,\n        Lock calldata _lock\n    ) validLock(_lock) external {\n        super._transfer(msg.sender, _to, _lock.totalAmount);\n        Lock storage lock = locks[_to];\n        require(lock.schedules.length + _lock.schedules.length < maxSchedules, \"Maximum locks on address\");\n        lock.totalAmount += _lock.totalAmount;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lock.schedules.push(\n                Schedule(\n                    _lock.schedules[i].amount, \n                _lock.schedules[i].expirationBlock\n            ));\n        }\n        totalLocked += _lock.totalAmount;\n        emit LockedTransfer(_lock, msg.sender, _to);\n    }\n\n    /*\n     * Internal functions\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        _updateLock(_from, _to, _amount);\n        super._transfer(_from, _to, _amount);\n    }\n\n    /// @dev internal function to update relevant lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param _amount transaction amount\n    function _updateLock(address _from, address _to, uint256 _amount) internal {\n        if (updateRecipientLock(_from, _to, _amount)) { return; }\n        updateSenderLock(_from, _to, _amount);\n    }\n\n    /// @dev internal function to update the sender's lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateSenderLock(address _from, address _to, uint256 sendAmount) internal {\n        Lock storage senderLock = locks[_from];\n\n        // no lock on sender\n        if (senderLock.totalAmount == 0) {\n            return;\n        }\n        // staking tokens\n        if (isStakeableContract[_to]) {\n            senderLock.amountStaked += sendAmount;\n            return;\n        }\n\n        uint256 amountToUnlock;\n        uint256 deleteOffset;\n        uint256 totalSenderSchedules = senderLock.schedules.length;\n        for (uint256 i = 0; i < totalSenderSchedules + deleteOffset; i++) {\n            uint256 index = i - deleteOffset;\n            if (block.timestamp >= senderLock.schedules[index].expirationBlock) {\n                amountToUnlock += senderLock.schedules[index].amount;\n                senderLock.schedules[index] = senderLock.schedules[totalSenderSchedules-1];\n                senderLock.schedules.pop();\n                deleteOffset++;\n                totalSenderSchedules--;\n                emit LockScheduleExpired(_from, locks[_from]);\n            }\n        }\n        uint256 availableAmount = \n            amountToUnlock + super.balanceOf(_from) + senderLock.amountStaked - senderLock.totalAmount;\n        senderLock.totalAmount -= amountToUnlock;\n        totalLocked = totalLocked < amountToUnlock ? 0 : totalLocked -= amountToUnlock;\n        require(availableAmount >= sendAmount, \"Insufficient unlocked funds\");\n        if (senderLock.totalAmount == 0) { \n            emit LockExpired( _from, locks[_from]);\n            delete locks[_from];\n        }\n    }\n\n    /// @dev internal function to update the recipient's lock if transaction is from stakeable contract\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateRecipientLock(address _from, address _to, uint256 sendAmount) internal returns (bool) {\n        if (!isStakeableContract[_from]) {\n            return false;\n        }\n\n        Lock storage recipientLock = locks[_to];\n        // lock does not exist\n        if (recipientLock.totalAmount == 0) {\n            return false;\n        }\n        recipientLock.amountStaked = \n        recipientLock.amountStaked >= sendAmount ? \n        recipientLock.amountStaked - sendAmount: 0;\n        return true;\n    }\n\n    // ADMIN\n\n    /// @dev external function to update minimum lock time\n    /// @param _newMin new minimum locking time\n    function setMinLockTime(uint256 _newMin) external onlyOwner() {\n        minLockTime = _newMin;\n    }\n\n    /// @dev external function to get minimum lock time\n    function getMinLockTime() external view returns (uint256) {\n        return minLockTime;\n    }\n\n    /// @dev external function to update maximum lock time\n    /// @param _newMax new maximum locking time\n    function setMaxLockTime(uint256 _newMax) external onlyOwner() {\n        maxLockTime = _newMax;\n    }\n\n    /// @dev external function to get maximum lock time\n    function getMaxLockTime() external view returns (uint256) {\n        return maxLockTime;\n    }\n\n    /// @dev external function to update maximum number of schedules per lock\n    /// @param _newMax new maximum number of shedules per lock\n    function setMaxSchedules(uint256 _newMax) external onlyOwner() {\n        maxSchedules = _newMax;\n    }\n\n    /// @dev external function to get maximum number of schedules per lock\n    function getMaxSchedules() external view returns (uint256) {\n        return maxSchedules;\n    }\n\n    /// @dev external function to add a stakeable contract\n    /// @param stakingContract address of the staking contract to be added\n    function addStakeableContract(address stakingContract) external onlyOwner() {\n        require(stakingContract != address(0), \"Invalid staking address\");\n        isStakeableContract[stakingContract] = true;\n    }\n\n    /// @dev external function to remove a stakeable contract\n    /// @param stakingContract address of the staking contract to be removed\n    function removeStakeableContract(address stakingContract) external onlyOwner() {\n        require(isStakeableContract[stakingContract], \"Invalid staking address\");\n        isStakeableContract[stakingContract] = false;\n    }\n\n    // WEB3 interface\n    function getLockSchedules(address owner) public view returns(Schedule[] memory){\n        Lock memory lock = locks[owner];\n        return lock.schedules;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return super.balanceOf(account) - lockedBalanceOf(account);\n    }\n\n    function lockedBalanceOf(address account) public view returns (uint256) {\n        Lock memory senderLock = locks[account];\n        uint256 lockedBalance;\n        for (uint256 i = 0; i < senderLock.schedules.length; i++) {\n            if (block.timestamp < senderLock.schedules[i].expirationBlock) {\n                lockedBalance += senderLock.schedules[i].amount;\n            }\n        }\n        return lockedBalance;\n    }\n\n    function refundLockedTokensToOwner() external {\n        uint256 lockedBalance = lockedBalanceOf(msg.sender);\n        totalLocked = totalLocked < lockedBalance ? 0 : totalLocked -= lockedBalance;\n        super._transfer(msg.sender, owner(), lockedBalanceOf(msg.sender));\n        delete locks[msg.sender];\n        emit LockReturned(msg.sender, totalLocked);\n    }\n}"
    },
    "contracts/SOURCE/NothingTokenV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20SOULV2.sol\";\n\ncontract NothingTokenV2 is ERC20SOULV2 {\n    function initialize (\n        uint256 initialSupply,\n        address[] calldata stakableContracts) external virtual initializer {\n        ERC20SOULV2.initializeERC20SOUL(\"NotSource\", \"NOTHING\", initialSupply, stakableContracts);\n    }\n}"
    },
    "contracts/SOURCE/SourceToken.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20SOUL.sol\";\n\ncontract SourceToken is ERC20SOUL {\n    function initialize (\n        uint256 initialSupply,\n        address[] calldata stakableContracts) external virtual initializer {\n        ERC20SOUL.initializeERC20SOUL(\"Source\", \"SOURCE\", initialSupply, stakableContracts);\n    }\n}"
    },
    "contracts/SOURCE/ERC20SOUL.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title ERC20SOUL - An ERC20 extension that enables the transfer of\n/// tokens alongside locking periods that can be applied to subsets of\n/// the total transfer amount. This implementation also allows the owner\n/// to specify staking contract addresses that locked addresses can \n/// interact with.\n/// @author Bridger Zoske - bridger@resourcenetwork.co\ncontract ERC20SOUL is ERC20Upgradeable, OwnableUpgradeable {\n    /*\n     *  Events\n     */\n    event LockedTransfer(\n        Lock lock,\n        address sender,\n        address recipient\n    );\n\n    event LockExpired(\n        address owner,\n        Lock lock\n    );\n\n    event LockScheduleExpired(\n        address owner,\n        Lock lock\n    );\n\n    /*\n     *  Storage\n     */\n    mapping (address => bool) public isStakeableContract;\n    mapping(address => Lock) public locks;\n    uint256 public minLockTime;\n    uint256 public maxLockTime;\n    uint256 public maxSchedules;\n\n    struct Lock {\n        uint256 totalAmount;\n        uint256 amountStaked;\n        Schedule[] schedules;\n    }\n\n    struct Schedule {\n        uint256 amount;\n        uint256 expirationBlock;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier validLock(Lock calldata _lock) {\n        require(_lock.totalAmount > 0, \"Invalid Lock amount\");\n        uint256 totalLocked;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            totalLocked += _lock.schedules[i].amount;\n            require(_lock.schedules[i].expirationBlock > \n                block.timestamp + minLockTime, \"Lock schedule does not meet minimum\");\n            require(_lock.schedules[i].expirationBlock < \n                block.timestamp + maxLockTime, \"Lock schedule does not meet maximum\");\n        }\n        require(totalLocked == _lock.totalAmount, \"Invalid Lock\");\n        _;\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract initialzer sets ERC20 token data and stakeable contracts\n    /// @param name Name of ERC20 token\n    /// @param symbol Symbol of ERC20 token\n    /// @param initialSupply Initial supply of ERC20 token\n    /// @param stakeableContracts List of valid staking contracts \n    function initializeERC20SOUL(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address[] calldata stakeableContracts\n    ) public virtual initializer {\n        __ERC20_init(name, symbol);\n        __Ownable_init();\n        _mint(msg.sender, initialSupply);\n        minLockTime = 1 days;\n        maxLockTime = 1825 days; \n        maxSchedules = 260;\n        for (uint256 i = 0; i < stakeableContracts.length; i++) {\n            require(stakeableContracts[i] != address(0), \"invalid stakeable contract address\");\n            isStakeableContract[stakeableContracts[i]] = true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        _updateLock(_from, _to, _amount);\n        super._transfer(_from, _to, _amount);\n    }\n\n    /// @dev Creates a valid recipient lock after transfering tokens\n    /// @param _to address to send tokens to\n    /// @param _lock valid lock data associated with transfer\n    function transferWithLock(\n        address _to,\n        Lock calldata _lock\n    ) validLock(_lock) external onlyOwner() {\n        super._transfer(msg.sender, _to, _lock.totalAmount);\n        Lock storage lock = locks[_to];\n        require(lock.schedules.length + _lock.schedules.length < maxSchedules, \"Maximum locks on address\");\n        lock.totalAmount += _lock.totalAmount;\n        for (uint256 i = 0; i < _lock.schedules.length; i++) {\n            lock.schedules.push(\n                Schedule(\n                    _lock.schedules[i].amount, \n                _lock.schedules[i].expirationBlock\n            ));\n        }\n        emit LockedTransfer(_lock, msg.sender, _to);\n    }\n\n    /// @dev internal function to update relevant lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param _amount transaction amount\n    function _updateLock(address _from, address _to, uint256 _amount) internal {\n        if (updateRecipientLock(_from, _to, _amount)) { return; }\n        updateSenderLock(_from, _to, _amount);\n    }\n\n    /// @dev internal function to update the sender's lock if any\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateSenderLock(address _from, address _to, uint256 sendAmount) internal {\n        Lock storage senderLock = locks[_from];\n\n        // no lock on sender\n        if (senderLock.totalAmount == 0) {\n            return;\n        }\n        // staking tokens\n        if (isStakeableContract[_to]) {\n            senderLock.amountStaked += sendAmount;\n            return;\n        }\n\n        uint256 amountToUnlock;\n        uint256 deleteOffset;\n        uint256 totalSenderSchedules = senderLock.schedules.length;\n        for (uint256 i = 0; i < totalSenderSchedules + deleteOffset; i++) {\n            uint256 index = i - deleteOffset;\n            if (block.timestamp >= senderLock.schedules[index].expirationBlock) {\n                amountToUnlock += senderLock.schedules[index].amount;\n                senderLock.schedules[index] = senderLock.schedules[totalSenderSchedules-1];\n                senderLock.schedules.pop();\n                deleteOffset++;\n                totalSenderSchedules--;\n                emit LockScheduleExpired(_from, locks[_from]);\n            }\n            \n\n        }\n        uint256 availableAmount = \n            amountToUnlock + balanceOf(_from) + senderLock.amountStaked - senderLock.totalAmount;\n        senderLock.totalAmount -= amountToUnlock;\n        require(availableAmount >= sendAmount, \"Insufficient unlocked funds\");\n        if (senderLock.totalAmount == 0) { \n            emit LockExpired( _from, locks[_from]);\n            delete locks[_from];\n        }\n    }\n\n    /// @dev internal function to update the recipient's lock if transaction is from stakeable contract\n    /// @param _from transaction sender\n    /// @param _to transaction recipient\n    /// @param sendAmount transaction amount\n    function updateRecipientLock(address _from, address _to, uint256 sendAmount) internal returns (bool) {\n        if (!isStakeableContract[_from]) {\n            return false;\n        }\n\n        Lock storage recipientLock = locks[_to];\n        // lock does not exist\n        if (recipientLock.totalAmount == 0) {\n            return false;\n        }\n        recipientLock.amountStaked = \n        recipientLock.amountStaked >= sendAmount ? \n        recipientLock.amountStaked - sendAmount: 0;\n        return true;\n    }\n\n    /// @dev external function to update minimum lock time\n    /// @param _newMin new minimum locking time\n    function setMinLockTime(uint256 _newMin) external onlyOwner() {\n        minLockTime = _newMin;\n    }\n\n    /// @dev external function to update maximum lock time\n    /// @param _newMax new maximum locking time\n    function setMaxLockTime(uint256 _newMax) external onlyOwner() {\n        maxLockTime = _newMax;\n    }\n    /// @dev external function to update maximum number of schedules per lock\n    /// @param _newMax new maximum number of shedules per lock\n    function setMaxSchedules(uint256 _newMax) external onlyOwner() {\n        maxSchedules = _newMax;\n    }\n\n    /// @dev external function to add a stakeable contract\n    /// @param stakingContract address of the staking contract to be added\n    function addStakeableContract(address stakingContract) external onlyOwner() {\n        require(stakingContract != address(0), \"Invalid staking address\");\n        isStakeableContract[stakingContract] = true;\n    }\n\n    /// @dev external function to remove a stakeable contract\n    /// @param stakingContract address of the staking contract to be removed\n    function removeStakeableContract(address stakingContract) external onlyOwner() {\n        require(isStakeableContract[stakingContract], \"Invalid staking address\");\n        isStakeableContract[stakingContract] = false;\n    }\n}"
    },
    "contracts/SOURCE/NothingToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20SOUL.sol\";\n\ncontract NothingToken is ERC20SOUL {\n    function initialize (\n        uint256 initialSupply,\n        address[] calldata stakableContracts) external virtual initializer {\n        ERC20SOUL.initializeERC20SOUL(\"NotSource\", \"NOTHING\", initialSupply, stakableContracts);\n    }\n}"
    },
    "contracts/CIP36/RUSDV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CIP36.sol\";\nimport \"./NetworkRegistry.sol\";\nimport \"./UnderwriteManager.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract RUSDV2 is CIP36 {\n    /*\n     *  REGISTERED: _to and _from must be registered wallets.\n     *  POSITIVE: _from must have a positive balance if _to is not a registered wallet.\n     *  NONE: no restrictions to _to and _from\n     */\n    enum Restriction { REGISTERED, POSITIVE, NONE }\n\n    /*\n     *  Events\n     */\n    event RestrictionUpdated(Restriction indexed state);\n    event RestrictionExpirationUpdated(uint256 restrictionRenewal);\n    event BalanceUpdate(\n        address sender, \n        address recipient, \n        uint256 senderBalance, \n        uint256 senderCreditBalance, \n        uint256 recipientBalance, \n        uint256 recipientCreditBalance);\n    \n    event BulkBalanceUpdate(\n        address sender, \n        address[] recipients, \n        uint256 senderBalance, \n        uint256 senderCreditBalance, \n        uint256[] recipientBalances, \n        uint256[] recipientCreditBalances);\n\n    /*\n     *  Storage\n     */\n    NetworkRegistry public registry;\n    UnderwriteManager public underwriteManager;\n    address public operator;\n\n    Restriction public restrictionState;\n    uint256 restrictionRenewal;\n    uint256 expirationSeconds;\n\n\n    modifier onlyAuthorized() override {\n        require(msg.sender == address(underwriteManager) || msg.sender == owner() || msg.sender == operator, \"Unauthorized caller\");\n        _;\n    }\n\n    function initializeRUSD(\n        address registryAddress,\n        uint256 _expiration,\n        address _underwriteManager,\n        address operatorAddress\n    ) external virtual initializer {\n        CIP36.initialize(\"rUSD\", \"rUSD\");\n        registry = NetworkRegistry(registryAddress);\n        underwriteManager = UnderwriteManager(_underwriteManager);\n        operator = operatorAddress;\n        restrictionState = Restriction.REGISTERED;\n        restrictionRenewal = block.timestamp;\n        expirationSeconds = _expiration;\n    }\n\n    /*\n     *  Overrides\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        _verifyNetworkRegistry(_from, _to, _amount);\n        super._transfer(_from, _to, _amount);\n        underwriteManager.updateReward(_from, _amount);\n        emit BalanceUpdate(\n            _from,\n            _to, \n            balanceOf(_from), \n            super.creditBalanceOf(_from),\n            balanceOf(_to),\n            super.creditBalanceOf(_to));\n    }\n\n    function bulkTransfer(address[] memory _to, uint256[] memory _values) public  \n    {\n        require(_to.length == _values.length);\n        for (uint256 i = 0; i < _to.length; i++) {\n            _transfer(msg.sender, _to[i], _values[i]);\n        }\n    }\n\n    function setCreditLimit(address _member, uint256 _limit) public override onlyAuthorized() {\n        super.setCreditLimit(_member, _limit);\n    }\n\n    function _verifyNetworkRegistry(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) private view {\n        if (restrictionState == Restriction.NONE) {\n            return;\n        }\n        if (restrictionState == Restriction.REGISTERED) {\n            require(registry.isMember(_from), \"Sender is not network member\");\n            require(registry.isMember(_to), \"Recipient is not network member\");\n        }\n        // if in positive restriction state, recipient is not in the registry and the sender's balance is negative\n        if (restrictionState == Restriction.POSITIVE && !registry.isMember(_to)) {\n            uint256 _balanceFrom = super.balanceOf(_from);\n            require(_balanceFrom - _amount >= 0, \"Insufficient balance for non network member\");\n        }\n    }\n\n    function restrictRegistered() external onlyOwner() {\n        if (restrictionState == Restriction.REGISTERED || restrictionState == Restriction.NONE) {\n            return;\n        }\n        emit RestrictionUpdated(Restriction.REGISTERED);\n        restrictionState = Restriction.REGISTERED;\n    }\n\n    function restrictPositiveBalance() external onlyOwner() {\n        if (restrictionState == Restriction.POSITIVE || restrictionState == Restriction.NONE) {\n            return;\n        }\n        emit RestrictionUpdated(Restriction.POSITIVE);\n        restrictionState = Restriction.POSITIVE;\n    }\n\n    function removeRestrictions() external {\n        if (restrictionState == Restriction.NONE) {\n            revert(\"Already non restrictive\");\n        }\n        if ((block.timestamp - restrictionRenewal) < expirationSeconds) {\n            revert(\"Restriction state not expired...\");\n        }\n        emit RestrictionUpdated(Restriction.NONE);\n        restrictionState = Restriction.NONE;\n    }\n\n    function updateRestrictionExpiration() external onlyOwner() {\n        emit RestrictionExpirationUpdated(block.timestamp);\n        restrictionRenewal = block.timestamp;\n    }\n}"
    },
    "contracts/CIP36/NetworkRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../iKeyWallet/IiKeyWalletDeployer.sol\";\n\n/// @title NetworkRegistry - Allows Network Members to be added and removed by Network Operators.\n/// @author Bridger Zoske - <bridger@resourcenetwork.co>\ncontract NetworkRegistry is OwnableUpgradeable  {\n    /*\n     *  Events\n     */\n    event MemberAddition(address[] indexed member);\n    event MemberRemoval(address indexed member);\n    event OperatorAddition(address indexed operator);\n    event OperatorRemoval(address indexed operator);\n    event WalletDeployed(address newMember);\n\n    /*\n     *  Storage\n     */\n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isOperator;\n    address[] public operators;\n    address[] public members;\n    address walletDeployer;\n\n    /*\n     *  Modifiers\n     */\n    modifier onlyOperator(address operator) {\n        require(isOperator[operator], \"address is not operator\");\n        _;\n    }\n\n    modifier memberDoesNotExist(address member) {\n        require(!isMember[member], \"member already exists\");\n        _;\n    }\n\n    modifier memberExists(address member) {\n        require(isMember[member], \"member does not exist\");\n        _;\n    }\n\n    modifier operatorDoesNotExist(address operator) {\n        require(!isOperator[operator], \"operator already exists\");\n        _;\n    }\n\n    modifier operatorExists(address operator) {\n        require(isOperator[operator], \"operator does not exist\");\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0), \"invalid operator address\");\n        _;\n    }\n\n    /*\n     * External functions\n     */\n    /// @dev Contract initialzer sets initial members and initial operators.\n    /// @param _members List of initial members.\n    /// @param _operators List of initial operators.\n    function initialize(address[] memory _members, address[] memory _operators, address _walletDeployer) external virtual initializer {\n        __Ownable_init();\n        for (uint256 i = 0; i < _members.length; i++) {\n            require(!isMember[_members[i]] && _members[i] != address(0));\n            isMember[_members[i]] = true;\n        }\n        for (uint256 j = 0; j < _operators.length; j++) {\n            require(!isOperator[_operators[j]] && _operators[j] != address(0));\n            isOperator[_operators[j]] = true;\n        }\n        members = _members;\n        operators = _operators;\n        operators.push(owner());\n        walletDeployer = _walletDeployer;\n        isOperator[owner()] = true;\n    }\n\n    /// @dev Allows operator to add a new member. Transaction has to be sent by an operator wallet.\n    /// @param _members Addresses of new members.\n    function addMembers(address[] memory _members) external onlyOperator(msg.sender) {\n        for (uint256 i = 0; i < _members.length; i++) {\n            require(!isMember[_members[i]] && _members[i] != address(0));\n            isMember[_members[i]] = true;\n            members.push(_members[i]);\n        }\n        emit MemberAddition(_members);\n    }\n\n    /// @dev Allows to remove a member. Transaction has to be sent by operator.\n    /// @param member Address of member.\n    function removeMember(address member) external onlyOperator(msg.sender) memberExists(member) {\n        isMember[member] = false;\n        for (uint256 i = 0; i < members.length - 1; i++)\n            if (members[i] == member) {\n                members[i] = members[members.length - 1];\n                break;\n            }\n        members.pop();\n        emit MemberRemoval(member);\n    }\n\n    /// @dev Allows to add a new operator. Transaction has to be sent by an operator wallet.\n    /// @param operator Address of new operator.\n    function addOperator(address operator)\n        external\n        onlyOperator(msg.sender)\n        operatorDoesNotExist(operator)\n        notNull(operator)\n    {\n        isOperator[operator] = true;\n        operators.push(operator);\n        emit OperatorAddition(operator);\n    }\n\n    /// @dev Allows to remove a operator. Transaction has to be sent by operator.\n    /// @param operator Address of operator.\n    function removeOperator(address operator) external onlyOperator(msg.sender) operatorExists(operator) {\n        require(operator != owner(), \"can't remove owner operator\");\n        isOperator[operator] = false;\n        for (uint256 i = 0; i < operators.length - 1; i++)\n            if (operators[i] == operator) {\n                operators[i] = operators[operators.length - 1];\n                break;\n            }\n        operators.pop();\n        emit OperatorRemoval(operator);\n    }\n\n    function deployNewWallet(\n        address[] memory _clients,\n        address[] memory _guardians, \n        address _coSigner,\n        uint256 _required) public onlyOperator(msg.sender) {\n        address newWallet = IiKeyWalletDeployer(walletDeployer).deployWallet(_clients, _guardians, _coSigner, _required);\n        OwnableUpgradeable(newWallet).transferOwnership(owner());\n        isMember[newWallet] = true;\n        members.push(newWallet);\n        emit WalletDeployed(newWallet);\n    }\n\n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns list of members.\n    /// @return List of member addresses.\n    function getMembers() external view returns (address[] memory) {\n        return members;\n    }\n\n    /// @dev Returns list of operators.\n    /// @return List of operator addresses.\n    function getOperators() external view returns (address[] memory) {\n        return operators;\n    }\n}"
    },
    "contracts/CIP36/UnderwriteManager.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"./CIP36.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n\ncontract UnderwriteManager is OwnableUpgradeable {\n    /*\n     *  Constants\n     */\n    uint256 public constant MU_PRICE_DENOMINATOR_USD = 5;\n    uint256 public constant LEVERAGE_DENOMINATOR = 5;\n    uint256 public constant MWEI = 1000000000000;\n    uint256 public constant REWARD_PERCENT = 2;\n    uint256 public constant CREDIT_RENEWAL = 180 days;\n    uint256 public constant MINIMUM_COLLATERAL = 600 ether;\n\n    /*\n     *  Storage\n     */\n    IERC20 public collateralToken;\n\n    // underwriter => underwritee => credit line\n    mapping(address => mapping(address => CreditLine)) public creditLines;\n    mapping(address => bool) private networks;\n    mapping(address => address) public underwriters;\n    bool public isActive;\n    uint256 public totalCollateral;\n\n    struct CreditLine {\n        uint256 collateral;\n        address networkToken;\n        uint256 issueDate;\n        uint256 reward;\n    }\n\n    struct CreditLineEvent {\n        address underwriter;\n        address underwritee;\n        CreditLine data;\n    }\n\n    struct CreditLineLimitEvent {\n        address underwriter;\n        address underwritee;\n        CreditLine data;\n        uint256 creditLimit;\n    }\n\n    /*\n     *  Events\n     */\n    event NewCreditLine(CreditLineLimitEvent creditLine);\n    event ExtendCreditLine(\n        CreditLineLimitEvent creditLine, \n        uint256 additionalCollateral\n    );\n    event CreditLineReward(CreditLineEvent creditLine);\n    event CreditLineRewardClaimed(\n        address underwriter,\n        address[] underwritees,\n        uint256[] rewards,\n        uint256 totalClaimed\n    );\n    event CreditLineWithdrawal(CreditLineLimitEvent creditLine);\n\n    function initialize(address _collateralTokenAddress) external virtual initializer {\n        collateralToken = IERC20(_collateralTokenAddress);\n        isActive = true;\n        __Ownable_init();\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier notNull(address _address) {\n        require(_address != address(0), \"Invalid address\");\n        _;\n    }\n\n    modifier onlyNetwork(address _address) {\n        require(networks[_address] == true || _address == owner(), \"Invalid network address\");\n        _;\n    }\n\n    modifier validCreditRenewal(address underwriter, address underwritee) {\n        uint256 issueDate = creditLines[underwriter][underwritee].issueDate;\n        require(block.timestamp - issueDate > CREDIT_RENEWAL, \"Credit limit still active\");\n        _;\n    }\n\n    modifier newCreditLine(address underwritee) {\n        require(underwriters[underwritee] == address(0), \"Address already underwritten\");\n        _;\n    }\n\n    modifier ownedCreditLine(address underwriter, address underwritee) {\n        require(underwriters[underwritee] == underwriter, \"Credit line not owned\");\n        _;\n    }\n\n    modifier active() {\n        require(isActive == true, \"Manager is inactive\");\n        _;\n    }\n\n    /*\n     * Public functions\n     */\n    function underwrite(\n        address networkToken,\n        uint256 collateralAmount,\n        address underwritee\n    ) newCreditLine(underwritee) active notNull(networkToken) notNull(underwritee) external {\n        CreditLine storage creditLine = creditLines[msg.sender][underwritee];\n        require(creditLine.collateral == 0, \"Credit line already underwritten\");\n        require(collateralAmount >= MINIMUM_COLLATERAL, \"Insufficient collateral\");\n        networks[networkToken] = true;\n        collateralToken.transferFrom(msg.sender, address(this), collateralAmount);\n        creditLine.collateral = collateralAmount;\n        creditLine.networkToken = networkToken;\n        creditLine.issueDate = block.timestamp;\n        uint256 creditLimit = calculateCredit(collateralAmount);\n        emit NewCreditLine(CreditLineLimitEvent(\n            msg.sender, \n            underwritee, \n            CreditLine(\n                creditLine.collateral, \n                creditLine.networkToken, \n                creditLine.issueDate,\n                0\n            ),\n            creditLimit\n        ));\n        CIP36(networkToken).setCreditLimit(underwritee, creditLimit); \n        totalCollateral += collateralAmount;\n        underwriters[underwritee] = msg.sender;\n    }\n\n    function extendCreditLine(address underwritee, uint256 collateralAmount) external active ownedCreditLine(msg.sender, underwritee) {\n        CreditLine storage creditLine = creditLines[msg.sender][underwritee];\n        require(creditLine.collateral >= MINIMUM_COLLATERAL, \"Credit line not underwritten\");\n        collateralToken.transferFrom(msg.sender, address(this), collateralAmount);\n        creditLine.collateral += collateralAmount;\n        uint256 creditLimit = calculateCredit(creditLine.collateral);\n        CIP36(creditLine.networkToken).setCreditLimit(underwritee, creditLimit);\n        totalCollateral += collateralAmount;\n        emit ExtendCreditLine(CreditLineLimitEvent(\n            msg.sender, \n            underwritee, \n            CreditLine(\n                creditLine.collateral, \n                creditLine.networkToken, \n                creditLine.issueDate,\n                0\n            ),\n            creditLimit\n        ), collateralAmount);\n    }\n\n    function withdraw(address underwritee) external validCreditRenewal(msg.sender, underwritee) notNull(underwritee) {\n        CreditLine memory creditLine = creditLines[msg.sender][underwritee];\n        uint256 collateral = creditLine.collateral;\n        require (collateral > 0, \"Can't withdraw from empty credit line\");\n        uint256 creditBalance = CIP36(creditLine.networkToken).creditBalanceOf(underwritee);\n        uint256 offsetBalance = creditBalance * MWEI;\n        uint256 total = creditLine.collateral + creditLine.reward - offsetBalance;\n        require( offsetBalance > 0, \"Can't withdraw from active credit line\");\n        CIP36(creditLine.networkToken).setCreditLimit(underwritee, 0);\n        collateralToken.transfer(msg.sender, total);\n        creditLines[msg.sender][underwritee] = CreditLine(0, address(0), 0, 0);\n        underwriters[underwritee] = address(0);\n        totalCollateral -= collateral;\n        emit CreditLineWithdrawal(CreditLineLimitEvent(\n            msg.sender, \n            underwritee, \n            CreditLine(\n                creditLine.collateral, \n                creditLine.networkToken, \n                creditLine.issueDate,\n                0\n            ),\n            0\n        ));\n    }\n\n    function renewCreditLine(address underwritee) external validCreditRenewal(msg.sender, underwritee) {\n        CreditLine storage creditLine = creditLines[msg.sender][underwritee];\n        require(underwriters[underwritee] == msg.sender, \"Must be underwriter to renew credit line\");\n        creditLine.issueDate = block.timestamp;\n    }\n\n    function updateReward(address underwritee, uint256 txAmount) external notNull(underwritee) onlyNetwork(msg.sender) {\n        address underwriter = underwriters[underwritee];\n        if (underwriter == address(0)) {\n            return;\n        }\n        CreditLine storage creditLine = creditLines[underwriter][underwritee];\n        if (creditLine.collateral == 0) {\n            return;\n        }\n        tryUpdateCreditLine(underwritee, underwriter);\n        uint256 reward = calculateReward(txAmount);\n        creditLine.reward += reward;\n        emit CreditLineReward(CreditLineEvent(\n            underwriter, \n            underwritee, \n            CreditLine(\n                creditLine.collateral, \n                creditLine.networkToken, \n                creditLine.issueDate,\n                reward\n            )\n        ));\n    }\n\n    function claimRewards(address[] memory underwritees) external {\n        uint256 totalReward = 0;\n        uint256[] memory rewards = new uint256[](underwritees.length);\n        for (uint256 i = 0; i < underwritees.length; i++) {\n            CreditLine storage creditLine = creditLines[msg.sender][underwritees[i]];\n            if (creditLine.reward > 0) {\n                rewards[i] = creditLine.reward;\n                totalReward += creditLine.reward;\n                creditLine.reward = 0;\n            }\n        }\n        require(totalReward > 0, \"No reward to claim\");\n        require(collateralToken.balanceOf(address(this)) - totalReward > totalCollateral, \"Insufficient funds in reward pool\");\n        collateralToken.transfer(msg.sender, totalReward);\n        emit CreditLineRewardClaimed(msg.sender, underwritees, rewards, totalReward);\n    }\n\n    function toggleActive() external onlyOwner() {\n        isActive = !isActive;\n    }\n\n    function addNetwork(address networkAddress) external onlyOwner() {\n        networks[networkAddress] = true;\n    }\n\n    function removeNetwork(address networkAddress) external onlyOwner() {\n        networks[networkAddress] = false;\n    }\n\n    // Returns calculation in mwei units\n    function calculateCredit(uint256 collateralAmount) public pure returns (uint256) {\n        return ((collateralAmount / MWEI) * (LEVERAGE_DENOMINATOR)) / MU_PRICE_DENOMINATOR_USD;\n    }\n    // Returns calculation in ether units\n    function calculateCollateral(uint256 creditAmount) public pure returns (uint256) {\n        return ((creditAmount * MWEI) * (LEVERAGE_DENOMINATOR)) / MU_PRICE_DENOMINATOR_USD;\n    }\n\n    /*\n     * Private functions\n     */\n    function calculateReward(uint256 txAmount) private pure returns (uint256) {\n        return (txAmount / 100) * REWARD_PERCENT * MWEI;\n    }\n\n    function tryUpdateCreditLine(address underwritee, address underwriter) private {\n        if ((block.timestamp - creditLines[underwriter][underwritee].issueDate) > CREDIT_RENEWAL + 1 days) {\n            creditLines[underwriter][underwritee].issueDate = block.timestamp;\n        }\n    }\n\n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns list of networks.\n    /// @return List of networks.\n    function isNetwork(address _address) external view returns (bool) {\n        return networks[_address];\n    }\n}"
    },
    "contracts/iKeyWallet/IiKeyWalletDeployer.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IiKeyWalletDeployer {\n    function deployWallet(\n        address[] memory _clients, \n        address[] memory _guardians, \n        address _coSigner, \n        uint256 _required) external returns (address);\n}\n"
    },
    "contracts/CIP36/RUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CIP36.sol\";\nimport \"./NetworkRegistry.sol\";\nimport \"./UnderwriteManager.sol\";\n\ncontract RUSD is CIP36 {\n    /*\n     *  REGISTERED: _to and _from must be registered wallets.\n     *  POSITIVE: _from must have a positive balance if _to is not a registered wallet.\n     *  NONE: no restrictions to _to and _from\n     */\n    enum Restriction { REGISTERED, POSITIVE, NONE }\n\n    /*\n     *  Events\n     */\n    event RestrictionUpdated(Restriction indexed state);\n    event RestrictionExpirationUpdated(uint256 restrictionRenewal);\n    event BalanceUpdate(\n        address sender, \n        address recipient, \n        uint256 senderBalance, \n        uint256 senderCreditBalance, \n        uint256 recipientBalance, \n        uint256 recipientCreditBalance);\n    \n    event BulkBalanceUpdate(\n        address sender, \n        address[] recipients, \n        uint256 senderBalance, \n        uint256 senderCreditBalance, \n        uint256[] recipientBalances, \n        uint256[] recipientCreditBalances);\n\n    /*\n     *  Storage\n     */\n    NetworkRegistry public registry; // TODO: use interface\n    UnderwriteManager public underwriteManager; // TODO: use interface\n    address public operator;\n\n    Restriction public restrictionState;\n    uint256 restrictionRenewal;\n    uint256 restrictionExpiration;\n\n\n    modifier onlyAuthorized() override {\n        require(msg.sender == address(underwriteManager) || msg.sender == owner() || msg.sender == operator, \"Unauthorized caller\");\n        _;\n    }\n\n    function initializeRUSD(\n        address registryAddress,\n        uint256 expiration,\n        address underwriteManagerAddress,\n        address operatorAddress\n    ) external virtual initializer {\n        CIP36.initialize(\"rUSD\", \"rUSD\");\n        registry = NetworkRegistry(registryAddress);\n        underwriteManager = UnderwriteManager(underwriteManagerAddress);\n        operator = operatorAddress;\n        restrictionState = Restriction.REGISTERED;\n        restrictionRenewal = block.timestamp;\n        restrictionExpiration = expiration;\n    }\n\n    /*\n     *  Overrides\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        _verifyContractState(_from, _to, _amount);\n        super._transfer(_from, _to, _amount);\n        //underwriteManager.tryUpdateReward(_from, _amount);\n        emit BalanceUpdate(\n            _from,\n            _to,\n            balanceOf(_from), \n            super.creditBalanceOf(_from),\n            balanceOf(_to),\n            super.creditBalanceOf(_to));\n    }\n\n    function bulkTransfer(address[] memory _to, uint256[] memory _values) public  \n    {\n        require(_to.length == _values.length);\n        for (uint256 i = 0; i < _to.length; i++) {\n            _transfer(msg.sender, _to[i], _values[i]);\n        }\n    }\n\n    function setCreditLimit(address _member, uint256 _limit) public override onlyAuthorized() {\n        super.setCreditLimit(_member, _limit);\n    }\n\n    function updateOperator(address newOperator) external onlyOwner() {\n        operator = newOperator;\n    }\n\n    function _verifyContractState(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) private view {\n        if (restrictionState == Restriction.NONE) {\n            return;\n        }\n        if (restrictionState == Restriction.REGISTERED) {\n            require(registry.isMember(_from), \"Sender is not network member\");\n            require(registry.isMember(_to), \"Recipient is not network member\");\n        } else if (!registry.isMember(_to)) {\n            uint256 _balanceFrom = super.balanceOf(_from);\n            require(_balanceFrom - _amount >= 0, \"Insufficient balance for non network member\");\n        }\n    }\n\n    function restrictRegistered() external onlyOwner() {\n        if (restrictionState != Restriction.POSITIVE) {\n            return;\n        }\n        emit RestrictionUpdated(Restriction.REGISTERED);\n        restrictionState = Restriction.REGISTERED;\n    }\n\n    function restrictPositiveBalance() external onlyOwner() {\n        if (restrictionState != Restriction.REGISTERED) {\n            return;\n        }\n        emit RestrictionUpdated(Restriction.POSITIVE);\n        restrictionState = Restriction.POSITIVE;\n    }\n\n    function freedom() external {\n        if (restrictionState == Restriction.NONE) {\n            revert(\"Already non restrictive\");\n        }\n        if ((block.timestamp - restrictionRenewal) < restrictionExpiration) {\n            revert(\"Restriction state not expired...\");\n        }\n        emit RestrictionUpdated(Restriction.NONE);\n        restrictionState = Restriction.NONE;\n    }\n\n    function updateRestrictionExpiration() external onlyOwner() {\n        emit RestrictionExpirationUpdated(block.timestamp);\n        restrictionRenewal = block.timestamp;\n    }\n}\n"
    },
    "contracts/CIP36/NetworkRegistryV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../iKeyWallet/IiKeyWalletDeployer.sol\";\n\n/// @title NetworkRegistry - Allows Network Members to be added and removed by Network Operators.\n/// @author Bridger Zoske - <bridger@resourcenetwork.co>\ncontract NetworkRegistryV2 is OwnableUpgradeable  {\n    /*\n     *  Events\n     */\n    event MemberAddition(address[] indexed member);\n    event MemberRemoval(address indexed member);\n    event OperatorAddition(address indexed operator);\n    event OperatorRemoval(address indexed operator);\n    event WalletDeployed(address newMember);\n\n    /*\n     *  Storage\n     */\n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isOperator;\n    address walletDeployer;\n\n    /*\n     *  Modifiers\n     */\n    modifier onlyOperator(address operator) {\n        require(isOperator[operator], \"address is not operator\");\n        _;\n    }\n\n    modifier memberDoesNotExist(address member) {\n        require(!isMember[member], \"member already exists\");\n        _;\n    }\n\n    modifier memberExists(address member) {\n        require(isMember[member], \"member does not exist\");\n        _;\n    }\n\n    modifier operatorDoesNotExist(address operator) {\n        require(!isOperator[operator], \"operator already exists\");\n        _;\n    }\n\n    modifier operatorExists(address operator) {\n        require(isOperator[operator], \"operator does not exist\");\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0), \"invalid operator address\");\n        _;\n    }\n\n    /*\n     * External functions\n     */\n    /// @dev Contract initialzer sets initial members and initial operators.\n    /// @param _members List of initial members.\n    /// @param _operators List of initial operators.\n    function initialize(address[] memory _members, address[] memory _operators, address _walletDeployer) external virtual initializer {\n        __Ownable_init();\n        for (uint256 i = 0; i < _members.length; i++) {\n            require(!isMember[_members[i]] && _members[i] != address(0));\n            isMember[_members[i]] = true;\n        }\n        for (uint256 j = 0; j < _operators.length; j++) {\n            require(!isOperator[_operators[j]] && _operators[j] != address(0));\n            isOperator[_operators[j]] = true;\n        }\n        walletDeployer = _walletDeployer;\n        isOperator[owner()] = true;\n    }\n\n    /// @dev Allows operator to add a new member. Transaction has to be sent by an operator wallet.\n    /// @param _members Addresses of new members.\n    function addMembers(address[] memory _members) external onlyOperator(msg.sender) {\n        for (uint256 i = 0; i < _members.length; i++) {\n            require(!isMember[_members[i]] && _members[i] != address(0), \"invalid members\");\n            isMember[_members[i]] = true;\n        }\n        emit MemberAddition(_members);\n    }\n\n    /// @dev Allows to remove a member. Transaction has to be sent by operator.\n    /// @param member Address of member.\n    function removeMember(address member) external onlyOperator(msg.sender) memberExists(member) {\n        isMember[member] = false;\n        emit MemberRemoval(member);\n    }\n\n    /// @dev Allows to add a new operator. Transaction has to be sent by an operator wallet.\n    /// @param operator Address of new operator.\n    function addOperator(address operator)\n        external\n        onlyOwner()\n        operatorDoesNotExist(operator)\n        notNull(operator)\n    {\n        isOperator[operator] = true;\n        emit OperatorAddition(operator);\n    }\n\n    /// @dev Allows to remove a operator. Transaction has to be sent by operator.\n    /// @param operator Address of operator.\n    function removeOperator(address operator) external onlyOwner() operatorExists(operator) {\n        require(operator != owner(), \"can't remove owner operator\");\n        isOperator[operator] = false;\n        emit OperatorRemoval(operator);\n    }\n\n    /// @dev Deploys a multisigwallet and adds it to members\n    /// @param clients client wallets of the multisig\n    /// @param guardians guardian wallets of the multisig\n    /// @param coSigner coSigner wallet of the multiSig\n    /// @param required required signatures of the multiSig \n    function deployWalletToRegistry(\n        address[] memory clients,\n        address[] memory guardians, \n        address coSigner,\n        uint256 required) public onlyOperator(msg.sender) {\n        // deploy new wallet\n        address newWallet = IiKeyWalletDeployer(walletDeployer).deployWallet(clients, guardians, coSigner, required);\n        // transfer ownership to registry owner\n        OwnableUpgradeable(newWallet).transferOwnership(owner());\n        // add new wallet to registry\n        isMember[newWallet] = true;\n        emit WalletDeployed(newWallet);\n    }\n}\n"
    },
    "contracts/iKeyWallet/iKeyWalletDeployer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./iKeyMultiSig.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n\n/// @title MultiSigWalletRegistry - Allows owner to added and remove multiSigWallet contracts from the registry.\n/// @author Bridger Zoske - <bridger@resourcenetwork.co>\ncontract iKeyWalletDeployer is OwnableUpgradeable {\n    event WalletDeployed(address multiSig);\n\n    function initialize() external initializer {\n        __Ownable_init();\n    }\n\n    function deployWallet(\n        address[] memory _clients,\n        address[] memory _guardians, \n        address _coSigner,\n        uint256 _required) public onlyOwner returns (address) {\n        iKeyMultiSig multiSig = new iKeyMultiSig();\n        multiSig.initialize(_clients, _guardians, _coSigner, _required);\n        multiSig.transferOwnership(msg.sender);\n        return address(multiSig);\n    }\n}\n"
    },
    "contracts/iKeyWallet/iKeyMultiSig.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title Identikey compatible Multisignature wallet\n/// @author Bridger Zoske - <bridger@resourcenetwork.co>\ncontract iKeyMultiSig is OwnableUpgradeable {\n    /*\n     *  Events\n     */\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\n    event Revocation(address indexed sender, uint256 indexed transactionId);\n    event Submission(uint256 indexed transactionId);\n    event Execution(uint256 indexed transactionId);\n    event ExecutionFailure(uint256 indexed transactionId);\n    event Deposit(address indexed sender, uint256 value);\n    event ClientAddition(address indexed client);\n    event ClientRemoval(address indexed client);\n    event GuardianAddition(address indexed guardian);\n    event GuardianRemoval(address indexed guardian);\n    event RequirementChange(uint256 required);\n\n    /*\n     *  Constants\n     */\n    uint256 public constant MAX_OWNER_COUNT = 50;\n\n    /*\n     *  Storage\n     */\n    mapping(uint256 => Transaction) public transactions;\n    mapping(uint256 => mapping(address => bool)) public confirmations;\n    mapping(address => bool) public clients;\n    mapping(address => bool) public guardians;\n    address public coSigner;\n    address[] public owners;\n    uint256 public required;\n    uint256 public transactionCount;\n\n    mapping(address => uint256) public nonces;\n\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        bool executed;\n    }\n\n    /*\n     *  Modifiers\n     */\n\n    modifier isOwner(address owner) {\n        require(clients[owner] || guardians[owner] || owner == coSigner);\n        _;\n    }\n    \n    modifier onlyWallet() {\n        require(msg.sender == address(this));\n        _;\n    }\n\n    modifier isNotClient(address client) {\n        require(!clients[client]);\n        _;\n    }\n\n    modifier isNotGuardian(address guardian) {\n        require(!guardians[guardian]);\n        _;\n    }\n\n    modifier isClient(address client) {\n        require(clients[client]);\n        _;\n    }\n\n    modifier isCoSigner(address _coSigner) {\n        require(_coSigner == coSigner);\n        _;\n    }\n\n    modifier isNotCoSigner(address _coSigner) {\n        require(_coSigner != coSigner);\n        _;\n    }\n    \n    modifier isGuardian(address guardian) {\n        require(guardians[guardian]);\n        _;\n    }\n\n    modifier transactionExists(uint256 transactionId) {\n        require(transactions[transactionId].destination != address(0));\n        _;\n    }\n\n    modifier confirmed(uint256 transactionId, address owner) {\n        require(confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint256 transactionId, address owner) {\n        require(!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint256 transactionId) {\n        require(!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier validRequirement(uint256 ownerCount, uint256 _required) {\n        require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0);\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    receive() external payable {\n        if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract initializer sets initial owners and required number of confirmations.\n    /// @param _clients List of initial clients.\n    /// @param _guardians List of initial guardians.\n    /// @param _coSigner the coSigner of the wallet. This wallet is immutable.\n    /// @param _required Number of required confirmations.\n    function initialize(\n        address[] memory _clients,\n        address[] memory _guardians, \n        address _coSigner,\n        uint256 _required) \n        external virtual initializer validRequirement(_clients.length + _guardians.length + 1, _required) {\n        __Ownable_init();\n        for (uint256 i = 0; i < _clients.length; i++) {\n            require(!clients[_clients[i]] && _clients[i] != address(0));\n            clients[_clients[i]] = true;\n            owners.push(_clients[i]);\n        }\n        for (uint256 i = 0; i < _guardians.length; i++) {\n            require(!guardians[_guardians[i]] && _guardians[i] != address(0));\n            guardians[_guardians[i]] = true;\n            owners.push(_guardians[i]);\n        }\n        coSigner = _coSigner;\n        owners.push(_coSigner);\n        required = _required;\n    }\n\n    /// @dev Allows to add a new client. Transaction has to be sent by wallet.\n    /// @param client Address of new client.\n    function addClient(address client)\n        external\n        onlyWallet\n        isNotClient(client)\n        notNull(client)\n        validRequirement(owners.length + 1, required)\n    {\n        clients[client] = true;\n        owners.push(client);\n        emit ClientAddition(client);\n    }\n\n    /// @dev Allows to add a new guardian. Transaction has to be sent by wallet.\n    /// @param guardian Address of new guardian.\n    function addGuardian(address guardian)\n        external\n        onlyWallet\n        isNotGuardian(guardian)\n        notNull(guardian)\n        validRequirement(owners.length + 1, required)\n    {\n        guardians[guardian] = true;\n        owners.push(guardian);\n        emit GuardianAddition(guardian);\n    }\n\n    /// @dev Allows to remove a client. Transaction has to be sent by wallet.\n    /// @param client Address of client.\n    function removeClient(address client) external onlyWallet isClient(client) {\n        clients[client] = false;\n        removeOwner(client);\n        emit ClientRemoval(client);\n    }\n\n    /// @dev Allows to remove a guardian. Transaction has to be sent by wallet.\n    /// @param guardian Address of guardian.\n    function removeGuardian(address guardian) external onlyWallet isGuardian(guardian) {\n        guardians[guardian] = false;\n        removeOwner(guardian);\n        emit GuardianRemoval(guardian);\n    }\n\n    function removeOwner(address owner) internal {\n        for (uint256 i = 0; i < owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.pop();\n        if (required > owners.length) changeRequirement(owners.length);\n    }\n\n    /// @dev Allows to replace an client with a new client. Transaction has to be sent by wallet.\n    /// @param client Address of client to be replaced.\n    /// @param newClient Address of new client.\n    function replaceClient(address client, address newClient)\n        external\n        onlyWallet\n        isClient(client)\n        isNotClient(newClient)\n    {\n        for (uint256 i = 0; i < owners.length; i++)\n            if (owners[i] == client) {\n                owners[i] = newClient;\n                break;\n            }\n        clients[client] = false;\n        clients[newClient] = true;\n        emit ClientRemoval(client);\n        emit ClientAddition(newClient);\n    }\n\n    /// @dev Allows to replace an guardian with a new guardian. Transaction has to be sent by wallet.\n    /// @param guardian Address of guardian to be replaced.\n    /// @param newGuardian Address of new guardian.\n    function replaceGuardian(address guardian, address newGuardian)\n        external\n        onlyWallet\n        isGuardian(guardian)\n        isNotGuardian(newGuardian)\n    {\n        for (uint256 i = 0; i < owners.length; i++)\n            if (owners[i] == guardian) {\n                owners[i] = newGuardian;\n                break;\n            }\n        guardians[guardian] = false;\n        guardians[newGuardian] = true;\n        emit GuardianRemoval(guardian);\n        emit GuardianAddition(newGuardian);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint256 _required) public onlyWallet validRequirement(owners.length, _required) {\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    /// @dev Allows to change the coSigner owner. Transaction has to be sent by coSigner address.\n    /// @param newCoSigner the address of the new coSigner.\n    function replaceCoSigner(address newCoSigner) public isCoSigner(msg.sender) isNotCoSigner(newCoSigner) {\n        for (uint256 i = 0; i < owners.length; i++)\n            if (owners[i] == newCoSigner) {\n                owners[i] = newCoSigner;\n                break;\n            }\n        coSigner = newCoSigner;\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(\n        bytes32 hash,\n        address expectedSigner,\n        bytes memory signature\n    ) internal pure {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        recover(hash, expectedSigner, v, r, s);\n    }\n\n    /**\n     * @notice Based on OpenZeppelin Implementation.\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        address expectedSigner,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer == expectedSigner, \"ECDSA: invalid signature\");\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    function prepareSubmitTransaction(\n        address destination,\n        uint256 value,\n        bytes memory data,\n        uint256 nonce\n    ) public view returns (bytes32) {\n        bytes4 functionSig = bytes4(keccak256(\"submitTransaction(address,uint256,bytes)\"));\n        return keccak256(abi.encodeWithSelector(functionSig, destination, value, data, address(this), nonce));\n    }\n\n    function submitTransactionByRelay(\n        address destination,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata sig,\n        address signer\n    ) external returns (uint256 transactionId) {\n        bytes32 hash = prepareSubmitTransaction(destination, value, data, nonces[signer]++);\n        recover(toEthSignedMessageHash(hash), signer, sig);\n        return submitTransaction(destination, value, data, signer);\n    }\n\n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return transactionId Returns transaction ID.\n    function submitTransaction(\n        address destination,\n        uint256 value,\n        bytes memory data,\n        address signer\n    ) internal returns (uint256 transactionId) {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId, signer);\n        return transactionId;\n    }\n\n    function prepareConfirmTransaction(uint256 transactionId, uint256 nonce) public view returns (bytes32) {\n        bytes4 functionSig = bytes4(keccak256(\"confirmTransaction(uint256)\"));\n        return keccak256(abi.encodeWithSelector(functionSig, transactionId, address(this), nonce));\n    }\n\n    function confirmTransactionByRelay(\n        uint256 transactionId,\n        bytes calldata sig,\n        address signer\n    ) external {\n        bytes32 hash = prepareConfirmTransaction(transactionId, nonces[signer]++);\n        recover(toEthSignedMessageHash(hash), signer, sig);\n        confirmTransaction(transactionId, signer);\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint256 transactionId, address signer)\n        internal\n        isOwner(signer)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, signer)\n    {\n        confirmations[transactionId][signer] = true;\n        emit Confirmation(signer, transactionId);\n        executeTransaction(transactionId, signer);\n    }\n\n    function prepareRevokeConfirmation(uint256 transactionId, uint256 nonce) public view returns (bytes32) {\n        bytes4 functionSig = bytes4(keccak256(\"revokeConfirmation(uint256)\"));\n        return keccak256(abi.encodeWithSelector(functionSig, transactionId, address(this), nonce));\n    }\n\n    function revokeConfirmationByRelay(\n        uint256 transactionId,\n        bytes calldata sig,\n        address signer\n    ) external {\n        bytes32 hash = prepareRevokeConfirmation(transactionId, nonces[signer]++);\n        recover(toEthSignedMessageHash(hash), signer, sig);\n        revokeConfirmation(transactionId, signer);\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint256 transactionId, address signer)\n        internal\n        isOwner(signer)\n        confirmed(transactionId, signer)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][signer] = false;\n        emit Revocation(signer, transactionId);\n    }\n\n    function prepareExecuteTransaction(uint256 transactionId, uint256 nonce) public view returns (bytes32) {\n        bytes4 functionSig = bytes4(keccak256(\"executeTransaction(uint256)\"));\n        return keccak256(abi.encodeWithSelector(functionSig, transactionId, address(this), nonce));\n    }\n\n    function executeTransactionByRelay(\n        uint256 transactionId,\n        bytes calldata sig,\n        address signer\n    ) external {\n        bytes32 hash = prepareExecuteTransaction(transactionId, nonces[signer]++);\n        recover(toEthSignedMessageHash(hash), signer, sig);\n        executeTransaction(transactionId, signer);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint256 transactionId, address signer)\n        internal\n        isOwner(signer)\n        confirmed(transactionId, signer)\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data)) emit Execution(transactionId);\n            else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    // call has been separated into its own function in order to take advantage\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\n    function external_call(\n        address destination,\n        uint256 value,\n        uint256 dataLength,\n        bytes memory data\n    ) internal returns (bool) {\n        bool result;\n        assembly {\n            let x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n            result := call(\n                gas(),\n                destination,\n                value,\n                d,\n                dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n                x,\n                0 // Output is ignored, therefore the output size is zero\n            )\n        }\n        return result;\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint256 transactionId) public view returns (bool) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]]) count += 1;\n            if (count == required) return true;\n        }\n        return false;\n    }\n\n    /*\n     * Internal functions\n     */\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return transactionId Returns transaction ID.\n    function addTransaction(\n        address destination,\n        uint256 value,\n        bytes memory data\n    ) internal notNull(destination) returns (uint256 transactionId) {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return count Number of confirmations.\n    function getConfirmationCount(uint256 transactionId) external view returns (uint256 count) {\n        for (uint256 i = 0; i < owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return count Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed) external view returns (uint256 count) {\n        for (uint256 i = 0; i < transactionCount; i++)\n            if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners() external view returns (address[] memory) {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return _confirmations Returns array of owner addresses.\n    function getConfirmations(uint256 transactionId) external view returns (address[] memory _confirmations) {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint256 count = 0;\n        uint256 i;\n        for (i = 0; i < owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return _transactionIds Returns array of transaction IDs.\n    // function getTransactionIds(\n    //     uint256 from,\n    //     uint256 to,\n    //     bool pending,\n    //     bool executed\n    // ) external view returns (uint256[] memory _transactionIds) {\n    //     uint256[] memory transactionIdsTemp = new uint256[](transactionCount);\n    //     uint256 count = 0;\n    //     uint256 i;\n    //     for (i = 0; i < transactionCount; i++)\n    //         if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\n    //             transactionIdsTemp[count] = i;\n    //             count += 1;\n    //         }\n    //     _transactionIds = new uint256[](to - from);\n    //     for (i = from; i < to; i++) _transactionIds[i - from] = transactionIdsTemp[i];\n    // }\n}\n"
    },
    "contracts/SOURCE/TokenVesting.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title TokenVesting - This contract enables the storage of\n/// tokens alongside a vesting schdule that release a subset\n/// of the total amount stored on a time schduel. This implementation \n/// also allows the owner to revoke a given schedule's tokens\n/// in the case that a beneficiary does not meet the vesting \n/// requirement. \n/// Original repository can be found at:\n/// https://github.com/abdelhamidbakhta/token-vesting-contracts\n/// @author Abdelhamid Bakhta - abdelhamid.bakhta@gmail.com\ncontract TokenVesting is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    struct VestingSchedule {\n        // whether or not the vesting has been revoked\n        bool revocable;\n        // beneficiary of tokens after they are released\n        bool revoked;\n        // whether or not the vesting is revocable\n        address beneficiary;\n        // cliff period in seconds\n        uint256 cliff;\n        // start time of the vesting period\n        uint256 start;\n        // duration of the vesting period in seconds\n        uint256 duration;\n        // duration of a slice period for the vesting in seconds\n        uint256 slicePeriodSeconds;\n        // total amount of tokens to be released at the end of the vesting\n        uint256 amountTotal;\n        // amount of tokens released\n        uint256 released;\n    }\n\n    // address of the ERC20 token\n    IERC20 immutable private _token;\n\n    bytes32[] private vestingSchedulesIds;\n    mapping(bytes32 => VestingSchedule) private vestingSchedules;\n    uint256 private vestingSchedulesTotalAmount;\n    mapping(address => uint256) private holdersVestingCount;\n\n    event Released(uint256 amount);\n    event Revoked();\n\n\n    /**\n    * @dev Reverts if the address is null.\n    */\n    modifier notNull(address _address) {\n        require(_address != address(0), \"Invalid address\");\n        _;\n    }\n\n    /**\n    * @dev Reverts if the vesting schedule does not exist or has been revoked.\n    */\n    modifier onlyIfVestingScheduleNotRevoked(bytes32 vestingScheduleId) {\n        require(vestingSchedules[vestingScheduleId].beneficiary != address(0));\n        require(vestingSchedules[vestingScheduleId].revoked == false);\n        _;\n    }\n\n    /**\n     * @dev Creates a vesting contract.\n     * @param token_ address of the ERC20 token contract\n     */\n    constructor(address token_) {\n        require(token_ != address(0x0));\n        _token = IERC20(token_);\n    }\n\n    /**\n    * @dev Returns the number of vesting schedules associated to a beneficiary.\n    * @return the number of vesting schedules\n    */\n    function getVestingSchedulesCountByBeneficiary(address _beneficiary)\n    external\n    view\n    returns(uint256){\n        return holdersVestingCount[_beneficiary];\n    }\n\n    /**\n    * @dev Returns the vesting schedule id at the given index.\n    * @return the vesting id\n    */\n    function getVestingIdAtIndex(uint256 index)\n    external\n    view\n    returns(bytes32){\n        require(index < getVestingSchedulesCount(), \"TokenVesting: index out of bounds\");\n        return vestingSchedulesIds[index];\n    }\n\n    /**\n    * @notice Returns the vesting schedule information for a given holder and index.\n    * @return the vesting schedule structure information\n    */\n    function getVestingScheduleByAddressAndIndex(address holder, uint256 index)\n    external\n    view\n    returns(VestingSchedule memory){\n        return getVestingSchedule(computeVestingScheduleIdForAddressAndIndex(holder, index));\n    }\n\n\n    /**\n    * @notice Returns the total amount of vesting schedules.\n    * @return the total amount of vesting schedules\n    */\n    function getVestingSchedulesTotalAmount()\n    external\n    view\n    returns(uint256){\n        return vestingSchedulesTotalAmount;\n    }\n\n    /**\n    * @dev Returns the address of the ERC20 token managed by the vesting contract.\n    */\n    function getToken()\n    external\n    view\n    returns(address){\n        return address(_token);\n    }\n\n    /**\n    * @notice Creates a new vesting schedule for a beneficiary.\n    * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n    * @param _start start time of the vesting period\n    * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\n    * @param _duration duration in seconds of the period in which the tokens will vest\n    * @param _slicePeriodSeconds duration of a slice period for the vesting in seconds\n    * @param _revocable whether the vesting is revocable or not\n    * @param _amount total amount of tokens to be released at the end of the vesting\n    */\n    function createVestingSchedule(\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _slicePeriodSeconds,\n        bool _revocable,\n        uint256 _amount\n    )\n        public\n        notNull(_beneficiary)\n        onlyOwner{\n        require(\n            getWithdrawableAmount() >= _amount,\n            \"TokenVesting: cannot create vesting schedule because not sufficient tokens\"\n        );\n        require(_duration > 0, \"TokenVesting: duration must be > 0\");\n        require(_amount > 0, \"TokenVesting: amount must be > 0\");\n        require(_slicePeriodSeconds >= 1, \"TokenVesting: slicePeriodSeconds must be >= 1\");\n        bytes32 vestingScheduleId = computeNextVestingScheduleIdForHolder(_beneficiary);\n        uint256 cliff = _start + _cliff;\n        vestingSchedules[vestingScheduleId] = VestingSchedule(\n            _revocable,\n            false,\n            _beneficiary,\n            cliff,\n            _start,\n            _duration,\n            _slicePeriodSeconds,\n            _amount,\n            0\n        );\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount + _amount;\n        vestingSchedulesIds.push(vestingScheduleId);\n        uint256 currentVestingCount = holdersVestingCount[_beneficiary];\n        holdersVestingCount[_beneficiary] = currentVestingCount + 1;\n    }\n\n    /**\n    * @notice Revokes the vesting schedule for given identifier.\n    * @param vestingScheduleId the vesting schedule identifier\n    */\n    function revoke(bytes32 vestingScheduleId)\n        public\n        onlyOwner\n        onlyIfVestingScheduleNotRevoked(vestingScheduleId){\n        VestingSchedule storage vestingSchedule = vestingSchedules[vestingScheduleId];\n        require(vestingSchedule.revocable == true, \"TokenVesting: vesting is not revocable\");\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\n        if(vestedAmount > 0){\n            release(vestingScheduleId, vestedAmount);\n        }\n        uint256 unreleased = vestingSchedule.amountTotal - vestingSchedule.released;\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - unreleased;\n        vestingSchedule.revoked = true;\n    }\n\n    /**\n    * @notice Withdraw the specified amount if possible.\n    * @param amount the amount to withdraw\n    */\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        onlyOwner{\n        require(getWithdrawableAmount() >= amount, \"TokenVesting: not enough withdrawable funds\");\n        _token.safeTransfer(owner(), amount);\n    }\n\n    /**\n    * @notice Release vested amount of tokens.\n    * @param vestingScheduleId the vesting schedule identifier\n    * @param amount the amount to release\n    */\n    function release(\n        bytes32 vestingScheduleId,\n        uint256 amount\n    )\n        public\n        nonReentrant\n        onlyIfVestingScheduleNotRevoked(vestingScheduleId){\n        VestingSchedule storage vestingSchedule = vestingSchedules[vestingScheduleId];\n        bool isBeneficiary = msg.sender == vestingSchedule.beneficiary;\n        bool isOwner = msg.sender == owner();\n        require(\n            isBeneficiary || isOwner,\n            \"TokenVesting: only beneficiary and owner can release vested tokens\"\n        );\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\n        require(vestedAmount >= amount, \"TokenVesting: cannot release tokens, not enough vested tokens\");\n        vestingSchedule.released = vestingSchedule.released + amount;\n        address payable beneficiaryPayable = payable(vestingSchedule.beneficiary);\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - amount;\n        _token.safeTransfer(beneficiaryPayable, amount);\n    }\n\n    /**\n    * @dev Returns the number of vesting schedules managed by this contract.\n    * @return the number of vesting schedules\n    */\n    function getVestingSchedulesCount()\n        public\n        view\n        returns(uint256){\n        return vestingSchedulesIds.length;\n    }\n\n    /**\n    * @notice Computes the vested amount of tokens for the given vesting schedule identifier.\n    * @return the vested amount\n    */\n    function computeReleasableAmount(bytes32 vestingScheduleId)\n        public\n        onlyIfVestingScheduleNotRevoked(vestingScheduleId)\n        view\n        returns(uint256){\n        VestingSchedule storage vestingSchedule = vestingSchedules[vestingScheduleId];\n        return _computeReleasableAmount(vestingSchedule);\n    }\n\n    /**\n    * @notice Returns the vesting schedule information for a given identifier.\n    * @return the vesting schedule structure information\n    */\n    function getVestingSchedule(bytes32 vestingScheduleId)\n        public\n        view\n        returns(VestingSchedule memory){\n        return vestingSchedules[vestingScheduleId];\n    }\n\n    /**\n    * @dev Returns the amount of tokens that can be withdrawn by the owner.\n    * @return the amount of tokens\n    */\n    function getWithdrawableAmount()\n        public\n        view\n        returns(uint256){\n        return _token.balanceOf(address(this)) - vestingSchedulesTotalAmount;\n    }\n\n    /**\n    * @dev Computes the next vesting schedule identifier for a given holder address.\n    */\n    function computeNextVestingScheduleIdForHolder(address holder)\n        public\n        view\n        returns(bytes32){\n        return computeVestingScheduleIdForAddressAndIndex(holder, holdersVestingCount[holder]);\n    }\n\n    /**\n    * @dev Returns the last vesting schedule for a given holder address.\n    */\n    function getLastVestingScheduleForHolder(address holder)\n        public\n        view\n        returns(VestingSchedule memory){\n        return vestingSchedules[computeVestingScheduleIdForAddressAndIndex(holder, holdersVestingCount[holder] - 1)];\n    }\n\n    /**\n    * @dev Computes the vesting schedule identifier for an address and an index.\n    */\n    function computeVestingScheduleIdForAddressAndIndex(address holder, uint256 index)\n        public\n        pure\n        returns(bytes32){\n        return keccak256(abi.encodePacked(holder, index));\n    }\n\n    /**\n    * @dev Computes the releasable amount of tokens for a vesting schedule.\n    * @return the amount of releasable tokens\n    */\n    function _computeReleasableAmount(VestingSchedule memory vestingSchedule)\n    internal\n    view\n    returns(uint256){\n        uint256 currentTime = block.timestamp;\n        if ((currentTime < vestingSchedule.cliff) || vestingSchedule.revoked == true) {\n            return 0;\n        } else if (currentTime >= vestingSchedule.start + vestingSchedule.duration) {\n            return vestingSchedule.amountTotal - vestingSchedule.released;\n        } else {\n            uint256 timeFromStart = currentTime - vestingSchedule.start;\n            uint secondsPerSlice = vestingSchedule.slicePeriodSeconds;\n            uint256 vestedSlicePeriods = timeFromStart / secondsPerSlice;\n            uint256 vestedSeconds = vestedSlicePeriods * secondsPerSlice;\n            uint256 vestedAmount = vestingSchedule.amountTotal * vestedSeconds / vestingSchedule.duration;\n            vestedAmount = vestedAmount - vestingSchedule.released;\n            return vestedAmount;\n        }\n    }\n}"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/CIP36/interface/ICIP36.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface ICIP36 {\n  function creditBalanceOf(address _member) external view returns (address);\n\n  function creditLimitOf(address _member) external view returns (uint256);\n\n  function creditLimitLeftOf(address _member) external view returns (uint256);\n\n  function setCreditLimit(address _member, uint256 _limit) external;\n}"
    },
    "contracts/CIP36/interface/INetworkRegistry.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface INetworkRegistry {\n    function addMembers(address[] memory _members) external;\n\n    function removeMember(address member) external;\n\n    function addOperator(address operator) external;\n\n    function removeOperator(address operator) external;\n\n    function deployWalletToRegistry(\n        address[] memory clients,\n        address[] memory guardians, \n        address coSigner,\n        uint256 required) external;\n}\n"
    },
    "contracts/CIP36/interface/IUnderwriteManager.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IUnderwriteManager {\n    function underwriteCreditLine(address networkToken, uint256 collateralAmount, address counterparty) external;\n\n    function extendCreditLine(address counterparty, uint256 collateralAmount) external;\n\n    function withdrawCreditLine(address counterparty) external;\n\n    function renewCreditLine(address counterparty) external;\n\n    function tryUpdateReward(address counterparty, uint256 txAmount) external;\n\n    function claimRewards(address[] memory counterparties) external;\n\n    function activate() external;\n\n    function deactivate() external;\n\n    function updateUnderwriters(address[] memory _underwriters, bool[] memory isUnderwriter) external;\n\n    function addNetwork(address networkAddress) external;\n\n    function removeNetwork(address networkAddress) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}